"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var chai_1 = require("chai");
var NoCustomNodes_1 = require("../../../../../../src/options/presets/NoCustomNodes");
var readFileAsString_1 = require("../../../../../helpers/readFileAsString");
var JavaScriptObfuscator_1 = require("../../../../../../src/JavaScriptObfuscator");
describe('BinaryExpressionControlFlowReplacer', function () {
    this.timeout(100000);
    describe('replace (binaryExpressionNode: ESTree.BinaryExpression,parentNode: ESTree.Node,controlFlowStorage: IStorage <ICustomNode>)', function () {
        describe('variant #1 - single binary expression', function () {
            var controlFlowStorageCallRegExp = /var *_0x([a-f0-9]){4,6} *= *_0x([a-f0-9]){4,6}\['\w{5}'\]\(0x1, *0x2\);/;
            var obfuscatedCode = void 0;
            before(function () {
                var code = readFileAsString_1.readFileAsString(__dirname + '/fixtures/input-1.js');
                var obfuscationResult = JavaScriptObfuscator_1.JavaScriptObfuscator.obfuscate(code, Object.assign({}, NoCustomNodes_1.NO_CUSTOM_NODES_PRESET, { controlFlowFlattening: true, controlFlowFlatteningThreshold: 1 }));
                obfuscatedCode = obfuscationResult.getObfuscatedCode();
            });
            it('should replace binary expression node with call to control flow storage node', function () {
                chai_1.assert.match(obfuscatedCode, controlFlowStorageCallRegExp);
            });
        });
        describe('variant #2 - multiple binary expressions with threshold = 1', function () {
            var expectedMatchErrorsCount = 0;
            var expectedChance = 0.5;
            var samplesCount = 1000;
            var delta = 0.1;
            var controlFlowStorageCallRegExp1 = /var *_0x(?:[a-f0-9]){4,6} *= *(_0x([a-f0-9]){4,6}\['\w{5}'\])\(0x1, *0x2\);/;
            var controlFlowStorageCallRegExp2 = /var *_0x(?:[a-f0-9]){4,6} *= *(_0x([a-f0-9]){4,6}\['\w{5}'\])\(0x2, *0x3\);/;
            var matchErrorsCount = 0,
                usingExistingIdentifierChance = void 0;
            before(function () {
                var code = readFileAsString_1.readFileAsString(__dirname + '/fixtures/input-2.js');
                var obfuscationResult = void 0,
                    obfuscatedCode = void 0,
                    firstMatchArray = void 0,
                    secondMatchArray = void 0,
                    firstMatch = void 0,
                    secondMatch = void 0,
                    equalsValue = 0;
                for (var i = 0; i < samplesCount; i++) {
                    obfuscationResult = JavaScriptObfuscator_1.JavaScriptObfuscator.obfuscate(code, Object.assign({}, NoCustomNodes_1.NO_CUSTOM_NODES_PRESET, { controlFlowFlattening: true, controlFlowFlatteningThreshold: 1 }));
                    obfuscatedCode = obfuscationResult.getObfuscatedCode();
                    firstMatchArray = obfuscatedCode.match(controlFlowStorageCallRegExp1);
                    secondMatchArray = obfuscatedCode.match(controlFlowStorageCallRegExp2);
                    if (!firstMatchArray || !secondMatchArray) {
                        matchErrorsCount++;
                        continue;
                    }
                    firstMatch = firstMatchArray ? firstMatchArray[1] : undefined;
                    secondMatch = secondMatchArray ? secondMatchArray[1] : undefined;
                    if (firstMatch === secondMatch) {
                        equalsValue++;
                    }
                }
                usingExistingIdentifierChance = equalsValue / samplesCount;
            });
            it('should replace binary expression node with call to control flow storage node', function () {
                chai_1.assert.equal(matchErrorsCount, expectedMatchErrorsCount);
            });
            it('should use existing identifier for control flow storage with expected chance', function () {
                chai_1.assert.closeTo(usingExistingIdentifierChance, expectedChance, delta);
            });
        });
    });
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQmluYXJ5RXhwcmVzc2lvbkNvbnRyb2xGbG93UmVwbGFjZXIuc3BlYy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uLy4uL3Rlc3QvZnVuY3Rpb25hbC10ZXN0cy9ub2RlLXRyYW5zZm9ybWVycy9jb250cm9sLWZsb3ctdHJhbnNmb3JtZXJzL2NvbnRyb2wtZmxvdy1yZXBsYWNlcnMvYmluYXJ5LWV4cHJlc3Npb24tY29udHJvbC1mbG93LXJlcGxhY2VyL0JpbmFyeUV4cHJlc3Npb25Db250cm9sRmxvd1JlcGxhY2VyLnNwZWMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7O0FBQUEscUJBQThCO0FBSTlCLDhCQUE2RjtBQUU3RixpQ0FBMkU7QUFFM0UscUNBQWtGO0FBRWxGLEFBQVEsU0FBQyxBQUFxQyx1Q0FBRTtBQUM1QyxBQUFJLFNBQUMsQUFBTyxRQUFDLEFBQU0sQUFBQyxBQUFDO0FBRXJCLEFBQVEsYUFBQyxBQUE0SCw4SEFBRTtBQUNuSSxBQUFRLGlCQUFDLEFBQXVDLHlDQUFFO0FBQzlDLGdCQUFNLEFBQTRCLCtCQUFXLEFBQXlFLEFBQUM7QUFFdkgsZ0JBQUksQUFBc0IsQUFBQztBQUUzQixBQUFNLG1CQUFDO0FBQ0gsb0JBQU0sQUFBSSxPQUFXLG1CQUFnQixpQkFBQyxBQUFTLFlBQUcsQUFBc0IsQUFBQyxBQUFDO0FBQzFFLG9CQUFNLEFBQWlCLG9CQUF1Qix1QkFBb0IscUJBQUMsQUFBUyxVQUN4RSxBQUFJLHdCQUVHLGdCQUFzQiwwQkFDekIsQUFBcUIsdUJBQUUsQUFBSSxNQUMzQixBQUE4QixnQ0FBRSxBQUFDLEFBRXhDLEFBQUM7QUFFRixBQUFjLGlDQUFHLEFBQWlCLGtCQUFDLEFBQWlCLEFBQUUsQUFBQyxBQUMzRDtBQUFDLEFBQUMsQUFBQztBQUVILEFBQUUsZUFBQyxBQUE4RSxnRkFBRTtBQUMvRSx1QkFBTSxPQUFDLEFBQUssTUFBQyxBQUFjLGdCQUFFLEFBQTRCLEFBQUMsQUFBQyxBQUMvRDtBQUFDLEFBQUMsQUFBQyxBQUNQO0FBQUMsQUFBQyxBQUFDO0FBRUgsQUFBUSxpQkFBQyxBQUE2RCwrREFBRTtBQUNwRSxnQkFBTSxBQUF3QiwyQkFBVyxBQUFDLEFBQUM7QUFDM0MsZ0JBQU0sQUFBYyxpQkFBVyxBQUFHLEFBQUM7QUFFbkMsZ0JBQU0sQUFBWSxlQUFXLEFBQUksQUFBQztBQUNsQyxnQkFBTSxBQUFLLFFBQVcsQUFBRyxBQUFDO0FBRTFCLGdCQUFNLEFBQTZCLGdDQUFXLEFBQTZFLEFBQUM7QUFDNUgsZ0JBQU0sQUFBNkIsZ0NBQVcsQUFBNkUsQUFBQztBQUU1SCxnQkFBSSxBQUFnQixtQkFBVyxBQUFDO2dCQUM1QixBQUFxQyxBQUFDO0FBRTFDLEFBQU0sbUJBQUM7QUFDSCxvQkFBTSxBQUFJLE9BQVcsbUJBQWdCLGlCQUFDLEFBQVMsWUFBRyxBQUFzQixBQUFDLEFBQUM7QUFFMUUsb0JBQUksQUFBcUM7b0JBQ3JDLEFBQXNCO29CQUN0QixBQUF3QztvQkFDeEMsQUFBeUM7b0JBQ3pDLEFBQThCO29CQUM5QixBQUErQjtvQkFDL0IsQUFBVyxjQUFXLEFBQUMsQUFBQztBQUU1QixBQUFHLEFBQUMscUJBQUMsSUFBSSxBQUFDLElBQUcsQUFBQyxHQUFFLEFBQUMsSUFBRyxBQUFZLGNBQUUsQUFBQyxBQUFFLEtBQUUsQUFBQztBQUNwQyxBQUFpQix3Q0FBRyx1QkFBb0IscUJBQUMsQUFBUyxVQUM5QyxBQUFJLHdCQUVHLGdCQUFzQiwwQkFDekIsQUFBcUIsdUJBQUUsQUFBSSxNQUMzQixBQUE4QixnQ0FBRSxBQUFDLEFBRXhDLEFBQUM7QUFFRixBQUFjLHFDQUFHLEFBQWlCLGtCQUFDLEFBQWlCLEFBQUUsQUFBQztBQUV2RCxBQUFlLHNDQUFHLEFBQWMsZUFBQyxBQUFLLE1BQUMsQUFBNkIsQUFBQyxBQUFDO0FBQ3RFLEFBQWdCLHVDQUFHLEFBQWMsZUFBQyxBQUFLLE1BQUMsQUFBNkIsQUFBQyxBQUFDO0FBRXZFLEFBQUUsQUFBQyx3QkFBQyxDQUFDLEFBQWUsbUJBQUksQ0FBQyxBQUFnQixBQUFDLGtCQUFDLEFBQUM7QUFDeEMsQUFBZ0IsQUFBRSxBQUFDO0FBRW5CLEFBQVEsQUFBQyxBQUNiO0FBQUM7QUFFRCxBQUFVLGlDQUFHLEFBQWUsa0JBQUcsQUFBZSxnQkFBQyxBQUFDLEFBQUMsS0FBRyxBQUFTLEFBQUM7QUFDOUQsQUFBVyxrQ0FBRyxBQUFnQixtQkFBRyxBQUFnQixpQkFBQyxBQUFDLEFBQUMsS0FBRyxBQUFTLEFBQUM7QUFFakUsQUFBRSxBQUFDLHdCQUFDLEFBQVUsZUFBSyxBQUFXLEFBQUMsYUFBQyxBQUFDO0FBQzdCLEFBQVcsQUFBRSxBQUFDLEFBQ2xCO0FBQUMsQUFDTDtBQUFDO0FBRUQsQUFBNkIsZ0RBQUcsQUFBVyxjQUFHLEFBQVksQUFBQyxBQUMvRDtBQUFDLEFBQUMsQUFBQztBQUVILEFBQUUsZUFBQyxBQUE4RSxnRkFBRTtBQUMvRSx1QkFBTSxPQUFDLEFBQUssTUFBQyxBQUFnQixrQkFBRSxBQUF3QixBQUFDLEFBQUMsQUFDN0Q7QUFBQyxBQUFDLEFBQUM7QUFFSCxBQUFFLGVBQUMsQUFBOEUsZ0ZBQUU7QUFDL0UsdUJBQU0sT0FBQyxBQUFPLFFBQUMsQUFBNkIsK0JBQUUsQUFBYyxnQkFBRSxBQUFLLEFBQUMsQUFBQyxBQUN6RTtBQUFDLEFBQUMsQUFBQyxBQUNQO0FBQUMsQUFBQyxBQUFDLEFBQ1A7QUFBQyxBQUFDLEFBQUMsQUFDUDtBQUFDLEFBQUMsQUFBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGFzc2VydCB9IGZyb20gJ2NoYWknO1xuXG5pbXBvcnQgeyBJT2JmdXNjYXRpb25SZXN1bHQgfSBmcm9tICcuLi8uLi8uLi8uLi8uLi8uLi9zcmMvaW50ZXJmYWNlcy9JT2JmdXNjYXRpb25SZXN1bHQnO1xuXG5pbXBvcnQgeyBOT19DVVNUT01fTk9ERVNfUFJFU0VUIH0gZnJvbSAnLi4vLi4vLi4vLi4vLi4vLi4vc3JjL29wdGlvbnMvcHJlc2V0cy9Ob0N1c3RvbU5vZGVzJztcblxuaW1wb3J0IHsgcmVhZEZpbGVBc1N0cmluZyB9IGZyb20gJy4uLy4uLy4uLy4uLy4uL2hlbHBlcnMvcmVhZEZpbGVBc1N0cmluZyc7XG5cbmltcG9ydCB7IEphdmFTY3JpcHRPYmZ1c2NhdG9yIH0gZnJvbSAnLi4vLi4vLi4vLi4vLi4vLi4vc3JjL0phdmFTY3JpcHRPYmZ1c2NhdG9yJztcblxuZGVzY3JpYmUoJ0JpbmFyeUV4cHJlc3Npb25Db250cm9sRmxvd1JlcGxhY2VyJywgZnVuY3Rpb24gKCkge1xuICAgIHRoaXMudGltZW91dCgxMDAwMDApO1xuXG4gICAgZGVzY3JpYmUoJ3JlcGxhY2UgKGJpbmFyeUV4cHJlc3Npb25Ob2RlOiBFU1RyZWUuQmluYXJ5RXhwcmVzc2lvbixwYXJlbnROb2RlOiBFU1RyZWUuTm9kZSxjb250cm9sRmxvd1N0b3JhZ2U6IElTdG9yYWdlIDxJQ3VzdG9tTm9kZT4pJywgKCkgPT4ge1xuICAgICAgICBkZXNjcmliZSgndmFyaWFudCAjMSAtIHNpbmdsZSBiaW5hcnkgZXhwcmVzc2lvbicsICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGNvbnRyb2xGbG93U3RvcmFnZUNhbGxSZWdFeHA6IFJlZ0V4cCA9IC92YXIgKl8weChbYS1mMC05XSl7NCw2fSAqPSAqXzB4KFthLWYwLTldKXs0LDZ9XFxbJ1xcd3s1fSdcXF1cXCgweDEsICoweDJcXCk7LztcblxuICAgICAgICAgICAgbGV0IG9iZnVzY2F0ZWRDb2RlOiBzdHJpbmc7XG5cbiAgICAgICAgICAgIGJlZm9yZSgoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgY29kZTogc3RyaW5nID0gcmVhZEZpbGVBc1N0cmluZyhfX2Rpcm5hbWUgKyAnL2ZpeHR1cmVzL2lucHV0LTEuanMnKTtcbiAgICAgICAgICAgICAgICBjb25zdCBvYmZ1c2NhdGlvblJlc3VsdDogSU9iZnVzY2F0aW9uUmVzdWx0ID0gSmF2YVNjcmlwdE9iZnVzY2F0b3Iub2JmdXNjYXRlKFxuICAgICAgICAgICAgICAgICAgICBjb2RlLFxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAuLi5OT19DVVNUT01fTk9ERVNfUFJFU0VULFxuICAgICAgICAgICAgICAgICAgICAgICAgY29udHJvbEZsb3dGbGF0dGVuaW5nOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29udHJvbEZsb3dGbGF0dGVuaW5nVGhyZXNob2xkOiAxXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAgICAgb2JmdXNjYXRlZENvZGUgPSBvYmZ1c2NhdGlvblJlc3VsdC5nZXRPYmZ1c2NhdGVkQ29kZSgpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGl0KCdzaG91bGQgcmVwbGFjZSBiaW5hcnkgZXhwcmVzc2lvbiBub2RlIHdpdGggY2FsbCB0byBjb250cm9sIGZsb3cgc3RvcmFnZSBub2RlJywgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGFzc2VydC5tYXRjaChvYmZ1c2NhdGVkQ29kZSwgY29udHJvbEZsb3dTdG9yYWdlQ2FsbFJlZ0V4cCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgZGVzY3JpYmUoJ3ZhcmlhbnQgIzIgLSBtdWx0aXBsZSBiaW5hcnkgZXhwcmVzc2lvbnMgd2l0aCB0aHJlc2hvbGQgPSAxJywgKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZXhwZWN0ZWRNYXRjaEVycm9yc0NvdW50OiBudW1iZXIgPSAwO1xuICAgICAgICAgICAgY29uc3QgZXhwZWN0ZWRDaGFuY2U6IG51bWJlciA9IDAuNTtcblxuICAgICAgICAgICAgY29uc3Qgc2FtcGxlc0NvdW50OiBudW1iZXIgPSAxMDAwO1xuICAgICAgICAgICAgY29uc3QgZGVsdGE6IG51bWJlciA9IDAuMTtcblxuICAgICAgICAgICAgY29uc3QgY29udHJvbEZsb3dTdG9yYWdlQ2FsbFJlZ0V4cDE6IFJlZ0V4cCA9IC92YXIgKl8weCg/OlthLWYwLTldKXs0LDZ9ICo9ICooXzB4KFthLWYwLTldKXs0LDZ9XFxbJ1xcd3s1fSdcXF0pXFwoMHgxLCAqMHgyXFwpOy87XG4gICAgICAgICAgICBjb25zdCBjb250cm9sRmxvd1N0b3JhZ2VDYWxsUmVnRXhwMjogUmVnRXhwID0gL3ZhciAqXzB4KD86W2EtZjAtOV0pezQsNn0gKj0gKihfMHgoW2EtZjAtOV0pezQsNn1cXFsnXFx3ezV9J1xcXSlcXCgweDIsICoweDNcXCk7LztcblxuICAgICAgICAgICAgbGV0IG1hdGNoRXJyb3JzQ291bnQ6IG51bWJlciA9IDAsXG4gICAgICAgICAgICAgICAgdXNpbmdFeGlzdGluZ0lkZW50aWZpZXJDaGFuY2U6IG51bWJlcjtcblxuICAgICAgICAgICAgYmVmb3JlKCgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBjb2RlOiBzdHJpbmcgPSByZWFkRmlsZUFzU3RyaW5nKF9fZGlybmFtZSArICcvZml4dHVyZXMvaW5wdXQtMi5qcycpO1xuXG4gICAgICAgICAgICAgICAgbGV0IG9iZnVzY2F0aW9uUmVzdWx0OiBJT2JmdXNjYXRpb25SZXN1bHQsXG4gICAgICAgICAgICAgICAgICAgIG9iZnVzY2F0ZWRDb2RlOiBzdHJpbmcsXG4gICAgICAgICAgICAgICAgICAgIGZpcnN0TWF0Y2hBcnJheTogUmVnRXhwTWF0Y2hBcnJheSB8IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIHNlY29uZE1hdGNoQXJyYXk6IFJlZ0V4cE1hdGNoQXJyYXkgfCBudWxsLFxuICAgICAgICAgICAgICAgICAgICBmaXJzdE1hdGNoOiBzdHJpbmcgfCB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgIHNlY29uZE1hdGNoOiBzdHJpbmcgfCB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgIGVxdWFsc1ZhbHVlOiBudW1iZXIgPSAwO1xuXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzYW1wbGVzQ291bnQ7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBvYmZ1c2NhdGlvblJlc3VsdCA9IEphdmFTY3JpcHRPYmZ1c2NhdG9yLm9iZnVzY2F0ZShcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGUsXG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLi4uTk9fQ1VTVE9NX05PREVTX1BSRVNFVCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250cm9sRmxvd0ZsYXR0ZW5pbmc6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udHJvbEZsb3dGbGF0dGVuaW5nVGhyZXNob2xkOiAxXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgICAgICAgb2JmdXNjYXRlZENvZGUgPSBvYmZ1c2NhdGlvblJlc3VsdC5nZXRPYmZ1c2NhdGVkQ29kZSgpO1xuXG4gICAgICAgICAgICAgICAgICAgIGZpcnN0TWF0Y2hBcnJheSA9IG9iZnVzY2F0ZWRDb2RlLm1hdGNoKGNvbnRyb2xGbG93U3RvcmFnZUNhbGxSZWdFeHAxKTtcbiAgICAgICAgICAgICAgICAgICAgc2Vjb25kTWF0Y2hBcnJheSA9IG9iZnVzY2F0ZWRDb2RlLm1hdGNoKGNvbnRyb2xGbG93U3RvcmFnZUNhbGxSZWdFeHAyKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoIWZpcnN0TWF0Y2hBcnJheSB8fCAhc2Vjb25kTWF0Y2hBcnJheSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hFcnJvcnNDb3VudCsrO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGZpcnN0TWF0Y2ggPSBmaXJzdE1hdGNoQXJyYXkgPyBmaXJzdE1hdGNoQXJyYXlbMV0gOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgIHNlY29uZE1hdGNoID0gc2Vjb25kTWF0Y2hBcnJheSA/IHNlY29uZE1hdGNoQXJyYXlbMV0gOiB1bmRlZmluZWQ7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGZpcnN0TWF0Y2ggPT09IHNlY29uZE1hdGNoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlcXVhbHNWYWx1ZSsrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdXNpbmdFeGlzdGluZ0lkZW50aWZpZXJDaGFuY2UgPSBlcXVhbHNWYWx1ZSAvIHNhbXBsZXNDb3VudDtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpdCgnc2hvdWxkIHJlcGxhY2UgYmluYXJ5IGV4cHJlc3Npb24gbm9kZSB3aXRoIGNhbGwgdG8gY29udHJvbCBmbG93IHN0b3JhZ2Ugbm9kZScsICgpID0+IHtcbiAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwobWF0Y2hFcnJvcnNDb3VudCwgZXhwZWN0ZWRNYXRjaEVycm9yc0NvdW50KTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpdCgnc2hvdWxkIHVzZSBleGlzdGluZyBpZGVudGlmaWVyIGZvciBjb250cm9sIGZsb3cgc3RvcmFnZSB3aXRoIGV4cGVjdGVkIGNoYW5jZScsICgpID0+IHtcbiAgICAgICAgICAgICAgICBhc3NlcnQuY2xvc2VUbyh1c2luZ0V4aXN0aW5nSWRlbnRpZmllckNoYW5jZSwgZXhwZWN0ZWRDaGFuY2UsIGRlbHRhKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9KTtcbn0pO1xuIl19