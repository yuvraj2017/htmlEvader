"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var chai_1 = require("chai");
var NoCustomNodes_1 = require("../../../../../src/options/presets/NoCustomNodes");
var getRegExpMatch_1 = require("../../../../helpers/getRegExpMatch");
var readFileAsString_1 = require("../../../../helpers/readFileAsString");
var JavaScriptObfuscator_1 = require("../../../../../src/JavaScriptObfuscator");
describe('VariableDeclarationTransformer', function () {
    describe('variant #1: default behaviour', function () {
        var variableDeclarationRegExp = /var *_0x([a-f0-9]){4,6} *= *'abc';/;
        var variableCallRegExp = /console\['log'\]\(_0x([a-f0-9]){4,6}\);/;
        var obfuscatedCode = void 0;
        before(function () {
            var code = readFileAsString_1.readFileAsString(__dirname + '/fixtures/simple-declaration.js');
            var obfuscationResult = JavaScriptObfuscator_1.JavaScriptObfuscator.obfuscate(code, Object.assign({}, NoCustomNodes_1.NO_CUSTOM_NODES_PRESET));
            obfuscatedCode = obfuscationResult.getObfuscatedCode();
        });
        it('match #1: should transform `variableDeclaration` node', function () {
            chai_1.assert.match(obfuscatedCode, variableDeclarationRegExp);
        });
        it('match #2: should transform `variableDeclaration` node', function () {
            chai_1.assert.match(obfuscatedCode, variableCallRegExp);
        });
    });
    describe('variant #2: parent block scope node is `Program` node', function () {
        var variableDeclarationRegExp = /var *test *= *0xa;/;
        var variableCallRegExp = /console\['log'\]\(test\);/;
        var obfuscatedCode = void 0;
        before(function () {
            var code = readFileAsString_1.readFileAsString(__dirname + '/fixtures/parent-block-scope-is-program-node.js');
            var obfuscationResult = JavaScriptObfuscator_1.JavaScriptObfuscator.obfuscate(code, Object.assign({}, NoCustomNodes_1.NO_CUSTOM_NODES_PRESET));
            obfuscatedCode = obfuscationResult.getObfuscatedCode();
        });
        it('match #1: shouldn\'t transform `variableDeclaration` node', function () {
            chai_1.assert.match(obfuscatedCode, variableDeclarationRegExp);
        });
        it('match #2: shouldn\'t transform `variableDeclaration` node', function () {
            chai_1.assert.match(obfuscatedCode, variableCallRegExp);
        });
    });
    describe('variant #3: scope of `var` kind', function () {
        var regExp = /console\['log'\]\(_0x([a-f0-9]){4,6}\);/;
        var obfuscatedCode = void 0;
        before(function () {
            var code = readFileAsString_1.readFileAsString(__dirname + '/fixtures/var-kind.js');
            var obfuscationResult = JavaScriptObfuscator_1.JavaScriptObfuscator.obfuscate(code, Object.assign({}, NoCustomNodes_1.NO_CUSTOM_NODES_PRESET));
            obfuscatedCode = obfuscationResult.getObfuscatedCode();
        });
        it('should transform variable call (`identifier` node) outside of block scope of node in which this variable was declared with `var` kind', function () {
            chai_1.assert.match(obfuscatedCode, regExp);
        });
    });
    describe('variant #4: scope of `let` kind', function () {
        var regExp = /console\['log'\]\(test\);/;
        var obfuscatedCode = void 0;
        before(function () {
            var code = readFileAsString_1.readFileAsString(__dirname + '/fixtures/let-kind.js');
            var obfuscationResult = JavaScriptObfuscator_1.JavaScriptObfuscator.obfuscate(code, Object.assign({}, NoCustomNodes_1.NO_CUSTOM_NODES_PRESET));
            obfuscatedCode = obfuscationResult.getObfuscatedCode();
        });
        it('shouldn\'t transform variable call (`identifier` node) outside of block scope of node in which this variable was declared with `let` kind', function () {
            chai_1.assert.match(obfuscatedCode, regExp);
        });
    });
    describe("variant #5: variable calls before variable declaration", function () {
        var functionBodyVariableCallRegExp = /console\['log'\]\(_0x([a-f0-9]){4,6}\['item'\]\);/;
        var variableCallBeforeDeclarationRegExp = /console\['log'\]\(_0x([a-f0-9]){4,6}\);/;
        var obfuscatedCode = void 0;
        before(function () {
            var code = readFileAsString_1.readFileAsString(__dirname + '/fixtures/variable-call-before-variable-declaration-1.js');
            var obfuscationResult = JavaScriptObfuscator_1.JavaScriptObfuscator.obfuscate(code, Object.assign({}, NoCustomNodes_1.NO_CUSTOM_NODES_PRESET));
            obfuscatedCode = obfuscationResult.getObfuscatedCode();
        });
        it('should transform variable call (`identifier` node name) before variable declaration if this call is inside function body', function () {
            chai_1.assert.match(obfuscatedCode, functionBodyVariableCallRegExp);
        });
        it('should transform variable call (`identifier` node name) before variable declaration', function () {
            chai_1.assert.match(obfuscatedCode, variableCallBeforeDeclarationRegExp);
        });
    });
    describe("variant #6: variable calls before variable declaration when function param has the same name as variables name", function () {
        var functionParamIdentifierRegExp = /function *_0x[a-f0-9]{4,6} *\((_0x[a-f0-9]{4,6})\,(_0x[a-f0-9]{4,6})\) *\{/;
        var innerFunctionParamIdentifierRegExp = /function _0x[a-f0-9]{4,6} *\((_0x[a-f0-9]{4,6})\) *\{/;
        var constructorIdentifierRegExp = /console\['log'\]\((_0x[a-f0-9]{4,6})\)/;
        var objectIdentifierRegExp = /return\{'t':(_0x[a-f0-9]{4,6})\}/;
        var variableDeclarationIdentifierRegExp = /var *(_0x[a-f0-9]{4,6});/;
        var outerFunctionParamIdentifierName = void 0,
            innerFunctionParamIdentifierName = void 0,
            constructorIdentifierName = void 0,
            objectIdentifierName = void 0,
            variableDeclarationIdentifierName = void 0;
        before(function () {
            var code = readFileAsString_1.readFileAsString(__dirname + '/fixtures/variable-call-before-variable-declaration-2.js');
            var obfuscationResult = JavaScriptObfuscator_1.JavaScriptObfuscator.obfuscate(code, Object.assign({}, NoCustomNodes_1.NO_CUSTOM_NODES_PRESET));
            var obfuscatedCode = obfuscationResult.getObfuscatedCode();
            outerFunctionParamIdentifierName = getRegExpMatch_1.getRegExpMatch(obfuscatedCode, functionParamIdentifierRegExp);
            innerFunctionParamIdentifierName = getRegExpMatch_1.getRegExpMatch(obfuscatedCode, innerFunctionParamIdentifierRegExp);
            constructorIdentifierName = getRegExpMatch_1.getRegExpMatch(obfuscatedCode, constructorIdentifierRegExp);
            objectIdentifierName = getRegExpMatch_1.getRegExpMatch(obfuscatedCode, objectIdentifierRegExp);
            variableDeclarationIdentifierName = getRegExpMatch_1.getRegExpMatch(obfuscatedCode, variableDeclarationIdentifierRegExp);
        });
        it('match #1: should\'t name variables inside inner function with names from outer function params', function () {
            chai_1.assert.notEqual(outerFunctionParamIdentifierName, constructorIdentifierName);
        });
        it('match #2: should\'t name variables inside inner function with names from outer function params', function () {
            chai_1.assert.notEqual(outerFunctionParamIdentifierName, innerFunctionParamIdentifierName);
        });
        it('match #1: should correct transform variables inside outer function body', function () {
            chai_1.assert.equal(outerFunctionParamIdentifierName, objectIdentifierName);
        });
        it('match #2: should correct transform variables inside outer function body', function () {
            chai_1.assert.equal(outerFunctionParamIdentifierName, variableDeclarationIdentifierName);
        });
        it('should correct transform variables inside inner function body', function () {
            chai_1.assert.equal(innerFunctionParamIdentifierName, constructorIdentifierName);
        });
        it('should keep equal names after transformation for variables with same names', function () {
            chai_1.assert.equal(variableDeclarationIdentifierName, objectIdentifierName);
        });
    });
    describe("variant #7: variable calls before variable declaration when catch clause param has the same name as variables name", function () {
        var catchClauseParamIdentifierRegExp = /catch *\((_0x[a-f0-9]{4,6})\) *\{/;
        var innerFunctionParamIdentifierRegExp = /function _0x[a-f0-9]{4,6} *\((_0x[a-f0-9]{4,6})\) *\{/;
        var constructorIdentifierRegExp = /console\['log'\]\((_0x[a-f0-9]{4,6})\)/;
        var objectIdentifierRegExp = /return\{'t':(_0x[a-f0-9]{4,6})\}/;
        var variableDeclarationIdentifierRegExp = /var *(_0x[a-f0-9]{4,6});/;
        var catchClauseParamIdentifierName = void 0,
            innerFunctionParamIdentifierName = void 0,
            constructorIdentifierName = void 0,
            objectIdentifierName = void 0,
            variableDeclarationIdentifierName = void 0;
        before(function () {
            var code = readFileAsString_1.readFileAsString(__dirname + '/fixtures/variable-call-before-variable-declaration-3.js');
            var obfuscationResult = JavaScriptObfuscator_1.JavaScriptObfuscator.obfuscate(code, Object.assign({}, NoCustomNodes_1.NO_CUSTOM_NODES_PRESET));
            var obfuscatedCode = obfuscationResult.getObfuscatedCode();
            catchClauseParamIdentifierName = getRegExpMatch_1.getRegExpMatch(obfuscatedCode, catchClauseParamIdentifierRegExp);
            innerFunctionParamIdentifierName = getRegExpMatch_1.getRegExpMatch(obfuscatedCode, innerFunctionParamIdentifierRegExp);
            constructorIdentifierName = getRegExpMatch_1.getRegExpMatch(obfuscatedCode, constructorIdentifierRegExp);
            objectIdentifierName = getRegExpMatch_1.getRegExpMatch(obfuscatedCode, objectIdentifierRegExp);
            variableDeclarationIdentifierName = getRegExpMatch_1.getRegExpMatch(obfuscatedCode, variableDeclarationIdentifierRegExp);
        });
        it('match #1: should\'t name variables inside inner function with names from catch clause param', function () {
            chai_1.assert.notEqual(catchClauseParamIdentifierName, constructorIdentifierName);
        });
        it('match #2: should\'t name variables inside inner function with names from catch clause param', function () {
            chai_1.assert.notEqual(catchClauseParamIdentifierName, innerFunctionParamIdentifierName);
        });
        it('equal #1: should correct transform variables inside catch clause body', function () {
            chai_1.assert.equal(catchClauseParamIdentifierName, objectIdentifierName);
        });
        it('equal #2: should correct transform variables inside catch clause body', function () {
            chai_1.assert.equal(catchClauseParamIdentifierName, variableDeclarationIdentifierName);
        });
        it('should correct transform variables inside inner function body', function () {
            chai_1.assert.equal(innerFunctionParamIdentifierName, constructorIdentifierName);
        });
        it('should keep equal names after transformation for variables with same names', function () {
            chai_1.assert.equal(variableDeclarationIdentifierName, objectIdentifierName);
        });
    });
    describe('variant #8: wrong replacement', function () {
        describe('variant #1: property node identifier', function () {
            var regExp = /var _0x([a-f0-9]){4,6} *= *\{'test/;
            var obfuscatedCode = void 0;
            before(function () {
                var code = readFileAsString_1.readFileAsString(__dirname + '/fixtures/property-identifier.js');
                var obfuscationResult = JavaScriptObfuscator_1.JavaScriptObfuscator.obfuscate(code, Object.assign({}, NoCustomNodes_1.NO_CUSTOM_NODES_PRESET));
                obfuscatedCode = obfuscationResult.getObfuscatedCode();
            });
            it('shouldn\'t replace property node identifier', function () {
                chai_1.assert.match(obfuscatedCode, regExp);
            });
        });
        describe('variant #2: computed member expression identifier', function () {
            var regExp = /_0x([a-f0-9]){4,6}\['test'\]/;
            var obfuscatedCode = void 0;
            before(function () {
                var code = readFileAsString_1.readFileAsString(__dirname + '/fixtures/member-expression-identifier.js');
                var obfuscationResult = JavaScriptObfuscator_1.JavaScriptObfuscator.obfuscate(code, Object.assign({}, NoCustomNodes_1.NO_CUSTOM_NODES_PRESET));
                obfuscatedCode = obfuscationResult.getObfuscatedCode();
            });
            it('shouldn\'t replace computed member expression identifier', function () {
                chai_1.assert.match(obfuscatedCode, regExp);
            });
        });
    });
    describe('variant #9: object pattern as variable declarator', function () {
        var objectPatternVariableDeclaratorRegExp = /var *\{ *bar *\} *= *\{ *'bar' *: *'foo' *\};/;
        var variableUsageRegExp = /console\['log'\]\(bar\);/;
        var obfuscatedCode = void 0;
        before(function () {
            var code = readFileAsString_1.readFileAsString(__dirname + '/fixtures/object-pattern.js');
            var obfuscationResult = JavaScriptObfuscator_1.JavaScriptObfuscator.obfuscate(code, Object.assign({}, NoCustomNodes_1.NO_CUSTOM_NODES_PRESET));
            obfuscatedCode = obfuscationResult.getObfuscatedCode();
        });
        it('match #1: shouldn\'t transform object pattern variable declarator', function () {
            chai_1.assert.match(obfuscatedCode, objectPatternVariableDeclaratorRegExp);
        });
        it('match #2: shouldn\'t transform object pattern variable declarator', function () {
            chai_1.assert.match(obfuscatedCode, variableUsageRegExp);
        });
    });
    describe('variant #10: array pattern as variable declarator', function () {
        var objectPatternVariableDeclaratorRegExp = /var *\[ *(_0x([a-f0-9]){4,6}), *(_0x([a-f0-9]){4,6}) *\] *= *\[0x1, *0x2\];/;
        var variableUsageRegExp = /console\['log'\]\((_0x([a-f0-9]){4,6}), *(_0x([a-f0-9]){4,6})\);/;
        var obfuscatedCode = void 0,
            objectPatternIdentifierName1 = void 0,
            objectPatternIdentifierName2 = void 0,
            identifierName1 = void 0,
            identifierName2 = void 0;
        before(function () {
            var code = readFileAsString_1.readFileAsString(__dirname + '/fixtures/array-pattern.js');
            var obfuscationResult = JavaScriptObfuscator_1.JavaScriptObfuscator.obfuscate(code, Object.assign({}, NoCustomNodes_1.NO_CUSTOM_NODES_PRESET));
            obfuscatedCode = obfuscationResult.getObfuscatedCode();
            objectPatternIdentifierName1 = getRegExpMatch_1.getRegExpMatch(obfuscatedCode, objectPatternVariableDeclaratorRegExp);
            objectPatternIdentifierName2 = getRegExpMatch_1.getRegExpMatch(obfuscatedCode, objectPatternVariableDeclaratorRegExp, 1);
            identifierName1 = getRegExpMatch_1.getRegExpMatch(obfuscatedCode, variableUsageRegExp);
            identifierName2 = getRegExpMatch_1.getRegExpMatch(obfuscatedCode, variableUsageRegExp, 1);
        });
        it('match #1: should transform array pattern variable declarator', function () {
            chai_1.assert.match(obfuscatedCode, objectPatternVariableDeclaratorRegExp);
        });
        it('match #2: should transform array pattern variable declarator', function () {
            chai_1.assert.match(obfuscatedCode, variableUsageRegExp);
        });
        it('equal #1: should keep same identifier names same for identifiers in variable declaration and after variable declaration', function () {
            chai_1.assert.equal(objectPatternIdentifierName1, identifierName1);
        });
        it('equal #2: should keep same identifier names same for identifiers in variable declaration and after variable declaration', function () {
            chai_1.assert.equal(objectPatternIdentifierName2, identifierName2);
        });
    });
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiVmFyaWFibGVEZWNsYXJhdGlvblRyYW5zZm9ybWVyLnNwZWMuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi90ZXN0L2Z1bmN0aW9uYWwtdGVzdHMvbm9kZS10cmFuc2Zvcm1lcnMvb2JmdXNjYXRpbmctdHJhbnNmb3JtZXJzL3ZhcmlhYmxlLWRlY2xhcmF0aW9uLXRyYW5zZm9ybWVyL1ZhcmlhYmxlRGVjbGFyYXRpb25UcmFuc2Zvcm1lci5zcGVjLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7OztBQUFBLHFCQUE4QjtBQUk5Qiw4QkFBMEY7QUFFMUYsK0JBQW9FO0FBQ3BFLGlDQUF3RTtBQUV4RSxxQ0FBK0U7QUFFL0UsQUFBUSxTQUFDLEFBQWdDLGtDQUFFO0FBQ3ZDLEFBQVEsYUFBQyxBQUErQixpQ0FBRTtBQUN0QyxZQUFNLEFBQXlCLDRCQUFXLEFBQW9DLEFBQUM7QUFDL0UsWUFBTSxBQUFrQixxQkFBVyxBQUF5QyxBQUFDO0FBRTdFLFlBQUksQUFBc0IsQUFBQztBQUUzQixBQUFNLGVBQUM7QUFDSCxnQkFBTSxBQUFJLE9BQVcsbUJBQWdCLGlCQUFDLEFBQVMsWUFBRyxBQUFpQyxBQUFDLEFBQUM7QUFDckYsZ0JBQU0sQUFBaUIsb0JBQXVCLHVCQUFvQixxQkFBQyxBQUFTLFVBQ3hFLEFBQUksd0JBRUcsZ0JBQXNCLEFBRWhDLEFBQUM7QUFFRixBQUFjLDZCQUFHLEFBQWlCLGtCQUFDLEFBQWlCLEFBQUUsQUFBQyxBQUMzRDtBQUFDLEFBQUMsQUFBQztBQUVILEFBQUUsV0FBQyxBQUF1RCx5REFBRTtBQUN4RCxtQkFBTSxPQUFDLEFBQUssTUFBQyxBQUFjLGdCQUFFLEFBQXlCLEFBQUMsQUFBQyxBQUM1RDtBQUFDLEFBQUMsQUFBQztBQUVILEFBQUUsV0FBQyxBQUF1RCx5REFBRTtBQUN4RCxtQkFBTSxPQUFDLEFBQUssTUFBQyxBQUFjLGdCQUFFLEFBQWtCLEFBQUMsQUFBQyxBQUNyRDtBQUFDLEFBQUMs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QUVILEFBQUUsV0FBQyxBQUF5SCwySEFBRTtBQUMxSCxtQkFBTSxPQUFDLEFBQUssTUFBQyxBQUE0Qiw4QkFBRSxBQUFlLEFBQUMsQUFBQyxBQUNoRTtBQUFDLEFBQUMsQUFBQyxBQUNQO0FBQUMsQUFBQyxBQUFDLEFBQ1A7QUFBQyxBQUFDLEFBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBhc3NlcnQgfSBmcm9tICdjaGFpJztcblxuaW1wb3J0IHsgSU9iZnVzY2F0aW9uUmVzdWx0IH0gZnJvbSAnLi4vLi4vLi4vLi4vLi4vc3JjL2ludGVyZmFjZXMvSU9iZnVzY2F0aW9uUmVzdWx0JztcblxuaW1wb3J0IHsgTk9fQ1VTVE9NX05PREVTX1BSRVNFVCB9IGZyb20gJy4uLy4uLy4uLy4uLy4uL3NyYy9vcHRpb25zL3ByZXNldHMvTm9DdXN0b21Ob2Rlcyc7XG5cbmltcG9ydCB7IGdldFJlZ0V4cE1hdGNoIH0gZnJvbSAnLi4vLi4vLi4vLi4vaGVscGVycy9nZXRSZWdFeHBNYXRjaCc7XG5pbXBvcnQgeyByZWFkRmlsZUFzU3RyaW5nIH0gZnJvbSAnLi4vLi4vLi4vLi4vaGVscGVycy9yZWFkRmlsZUFzU3RyaW5nJztcblxuaW1wb3J0IHsgSmF2YVNjcmlwdE9iZnVzY2F0b3IgfSBmcm9tICcuLi8uLi8uLi8uLi8uLi9zcmMvSmF2YVNjcmlwdE9iZnVzY2F0b3InO1xuXG5kZXNjcmliZSgnVmFyaWFibGVEZWNsYXJhdGlvblRyYW5zZm9ybWVyJywgKCkgPT4ge1xuICAgIGRlc2NyaWJlKCd2YXJpYW50ICMxOiBkZWZhdWx0IGJlaGF2aW91cicsICgpID0+IHtcbiAgICAgICAgY29uc3QgdmFyaWFibGVEZWNsYXJhdGlvblJlZ0V4cDogUmVnRXhwID0gL3ZhciAqXzB4KFthLWYwLTldKXs0LDZ9ICo9IConYWJjJzsvO1xuICAgICAgICBjb25zdCB2YXJpYWJsZUNhbGxSZWdFeHA6IFJlZ0V4cCA9IC9jb25zb2xlXFxbJ2xvZydcXF1cXChfMHgoW2EtZjAtOV0pezQsNn1cXCk7LztcblxuICAgICAgICBsZXQgb2JmdXNjYXRlZENvZGU6IHN0cmluZztcblxuICAgICAgICBiZWZvcmUoKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgY29kZTogc3RyaW5nID0gcmVhZEZpbGVBc1N0cmluZyhfX2Rpcm5hbWUgKyAnL2ZpeHR1cmVzL3NpbXBsZS1kZWNsYXJhdGlvbi5qcycpO1xuICAgICAgICAgICAgY29uc3Qgb2JmdXNjYXRpb25SZXN1bHQ6IElPYmZ1c2NhdGlvblJlc3VsdCA9IEphdmFTY3JpcHRPYmZ1c2NhdG9yLm9iZnVzY2F0ZShcbiAgICAgICAgICAgICAgICBjb2RlLFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgLi4uTk9fQ1VTVE9NX05PREVTX1BSRVNFVFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIG9iZnVzY2F0ZWRDb2RlID0gb2JmdXNjYXRpb25SZXN1bHQuZ2V0T2JmdXNjYXRlZENvZGUoKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaXQoJ21hdGNoICMxOiBzaG91bGQgdHJhbnNmb3JtIGB2YXJpYWJsZURlY2xhcmF0aW9uYCBub2RlJywgKCkgPT4ge1xuICAgICAgICAgICAgYXNzZXJ0Lm1hdGNoKG9iZnVzY2F0ZWRDb2RlLCB2YXJpYWJsZURlY2xhcmF0aW9uUmVnRXhwKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaXQoJ21hdGNoICMyOiBzaG91bGQgdHJhbnNmb3JtIGB2YXJpYWJsZURlY2xhcmF0aW9uYCBub2RlJywgKCkgPT4ge1xuICAgICAgICAgICAgYXNzZXJ0Lm1hdGNoKG9iZnVzY2F0ZWRDb2RlLCB2YXJpYWJsZUNhbGxSZWdFeHApO1xuICAgICAgICB9KTtcbiAgICB9KTtcblxuICAgIGRlc2NyaWJlKCd2YXJpYW50ICMyOiBwYXJlbnQgYmxvY2sgc2NvcGUgbm9kZSBpcyBgUHJvZ3JhbWAgbm9kZScsICgpID0+IHtcbiAgICAgICAgY29uc3QgdmFyaWFibGVEZWNsYXJhdGlvblJlZ0V4cDogUmVnRXhwID0gL3ZhciAqdGVzdCAqPSAqMHhhOy87XG4gICAgICAgIGNvbnN0IHZhcmlhYmxlQ2FsbFJlZ0V4cDogUmVnRXhwID0gL2NvbnNvbGVcXFsnbG9nJ1xcXVxcKHRlc3RcXCk7LztcblxuICAgICAgICBsZXQgb2JmdXNjYXRlZENvZGU6IHN0cmluZztcblxuICAgICAgICBiZWZvcmUoKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgY29kZTogc3RyaW5nID0gcmVhZEZpbGVBc1N0cmluZyhfX2Rpcm5hbWUgKyAnL2ZpeHR1cmVzL3BhcmVudC1ibG9jay1zY29wZS1pcy1wcm9ncmFtLW5vZGUuanMnKTtcbiAgICAgICAgICAgIGNvbnN0IG9iZnVzY2F0aW9uUmVzdWx0OiBJT2JmdXNjYXRpb25SZXN1bHQgPSBKYXZhU2NyaXB0T2JmdXNjYXRvci5vYmZ1c2NhdGUoXG4gICAgICAgICAgICAgICAgY29kZSxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIC4uLk5PX0NVU1RPTV9OT0RFU19QUkVTRVRcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICBvYmZ1c2NhdGVkQ29kZSA9IG9iZnVzY2F0aW9uUmVzdWx0LmdldE9iZnVzY2F0ZWRDb2RlKCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGl0KCdtYXRjaCAjMTogc2hvdWxkblxcJ3QgdHJhbnNmb3JtIGB2YXJpYWJsZURlY2xhcmF0aW9uYCBub2RlJywgKCkgPT4ge1xuICAgICAgICAgICAgYXNzZXJ0Lm1hdGNoKG9iZnVzY2F0ZWRDb2RlLCB2YXJpYWJsZURlY2xhcmF0aW9uUmVnRXhwKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaXQoJ21hdGNoICMyOiBzaG91bGRuXFwndCB0cmFuc2Zvcm0gYHZhcmlhYmxlRGVjbGFyYXRpb25gIG5vZGUnLCAoKSA9PiB7XG4gICAgICAgICAgICBhc3NlcnQubWF0Y2gob2JmdXNjYXRlZENvZGUsIHZhcmlhYmxlQ2FsbFJlZ0V4cCk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgZGVzY3JpYmUoJ3ZhcmlhbnQgIzM6IHNjb3BlIG9mIGB2YXJgIGtpbmQnLCAoKSA9PiB7XG4gICAgICAgIGNvbnN0IHJlZ0V4cDogUmVnRXhwID0gL2NvbnNvbGVcXFsnbG9nJ1xcXVxcKF8weChbYS1mMC05XSl7NCw2fVxcKTsvO1xuXG4gICAgICAgIGxldCBvYmZ1c2NhdGVkQ29kZTogc3RyaW5nO1xuXG4gICAgICAgIGJlZm9yZSgoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBjb2RlOiBzdHJpbmcgPSByZWFkRmlsZUFzU3RyaW5nKF9fZGlybmFtZSArICcvZml4dHVyZXMvdmFyLWtpbmQuanMnKTtcbiAgICAgICAgICAgIGNvbnN0IG9iZnVzY2F0aW9uUmVzdWx0OiBJT2JmdXNjYXRpb25SZXN1bHQgPSBKYXZhU2NyaXB0T2JmdXNjYXRvci5vYmZ1c2NhdGUoXG4gICAgICAgICAgICAgICAgY29kZSxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIC4uLk5PX0NVU1RPTV9OT0RFU19QUkVTRVRcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICBvYmZ1c2NhdGVkQ29kZSA9IG9iZnVzY2F0aW9uUmVzdWx0LmdldE9iZnVzY2F0ZWRDb2RlKCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGl0KCdzaG91bGQgdHJhbnNmb3JtIHZhcmlhYmxlIGNhbGwgKGBpZGVudGlmaWVyYCBub2RlKSBvdXRzaWRlIG9mIGJsb2NrIHNjb3BlIG9mIG5vZGUgaW4gd2hpY2ggdGhpcyB2YXJpYWJsZSB3YXMgZGVjbGFyZWQgd2l0aCBgdmFyYCBraW5kJywgKCkgPT4ge1xuICAgICAgICAgICAgYXNzZXJ0Lm1hdGNoKG9iZnVzY2F0ZWRDb2RlLCByZWdFeHApO1xuICAgICAgICB9KTtcbiAgICB9KTtcblxuICAgIGRlc2NyaWJlKCd2YXJpYW50ICM0OiBzY29wZSBvZiBgbGV0YCBraW5kJywgKCkgPT4ge1xuICAgICAgICBjb25zdCByZWdFeHA6IFJlZ0V4cCA9IC9jb25zb2xlXFxbJ2xvZydcXF1cXCh0ZXN0XFwpOy87XG5cbiAgICAgICAgbGV0IG9iZnVzY2F0ZWRDb2RlOiBzdHJpbmc7XG5cbiAgICAgICAgYmVmb3JlKCgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGNvZGU6IHN0cmluZyA9IHJlYWRGaWxlQXNTdHJpbmcoX19kaXJuYW1lICsgJy9maXh0dXJlcy9sZXQta2luZC5qcycpO1xuICAgICAgICAgICAgY29uc3Qgb2JmdXNjYXRpb25SZXN1bHQ6IElPYmZ1c2NhdGlvblJlc3VsdCA9IEphdmFTY3JpcHRPYmZ1c2NhdG9yLm9iZnVzY2F0ZShcbiAgICAgICAgICAgICAgICBjb2RlLFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgLi4uTk9fQ1VTVE9NX05PREVTX1BSRVNFVFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIG9iZnVzY2F0ZWRDb2RlID0gb2JmdXNjYXRpb25SZXN1bHQuZ2V0T2JmdXNjYXRlZENvZGUoKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaXQoJ3Nob3VsZG5cXCd0IHRyYW5zZm9ybSB2YXJpYWJsZSBjYWxsIChgaWRlbnRpZmllcmAgbm9kZSkgb3V0c2lkZSBvZiBibG9jayBzY29wZSBvZiBub2RlIGluIHdoaWNoIHRoaXMgdmFyaWFibGUgd2FzIGRlY2xhcmVkIHdpdGggYGxldGAga2luZCcsICgpID0+IHtcbiAgICAgICAgICAgIGFzc2VydC5tYXRjaChvYmZ1c2NhdGVkQ29kZSwgcmVnRXhwKTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBkZXNjcmliZShgdmFyaWFudCAjNTogdmFyaWFibGUgY2FsbHMgYmVmb3JlIHZhcmlhYmxlIGRlY2xhcmF0aW9uYCwgKCkgPT4ge1xuICAgICAgICBjb25zdCBmdW5jdGlvbkJvZHlWYXJpYWJsZUNhbGxSZWdFeHA6IFJlZ0V4cCA9IC9jb25zb2xlXFxbJ2xvZydcXF1cXChfMHgoW2EtZjAtOV0pezQsNn1cXFsnaXRlbSdcXF1cXCk7LztcbiAgICAgICAgY29uc3QgdmFyaWFibGVDYWxsQmVmb3JlRGVjbGFyYXRpb25SZWdFeHA6IFJlZ0V4cCA9IC9jb25zb2xlXFxbJ2xvZydcXF1cXChfMHgoW2EtZjAtOV0pezQsNn1cXCk7LztcblxuICAgICAgICBsZXQgb2JmdXNjYXRlZENvZGU6IHN0cmluZztcblxuICAgICAgICBiZWZvcmUoKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgY29kZTogc3RyaW5nID0gcmVhZEZpbGVBc1N0cmluZyhfX2Rpcm5hbWUgKyAnL2ZpeHR1cmVzL3ZhcmlhYmxlLWNhbGwtYmVmb3JlLXZhcmlhYmxlLWRlY2xhcmF0aW9uLTEuanMnKTtcbiAgICAgICAgICAgIGNvbnN0IG9iZnVzY2F0aW9uUmVzdWx0OiBJT2JmdXNjYXRpb25SZXN1bHQgPSBKYXZhU2NyaXB0T2JmdXNjYXRvci5vYmZ1c2NhdGUoXG4gICAgICAgICAgICAgICAgY29kZSxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIC4uLk5PX0NVU1RPTV9OT0RFU19QUkVTRVRcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICBvYmZ1c2NhdGVkQ29kZSA9IG9iZnVzY2F0aW9uUmVzdWx0LmdldE9iZnVzY2F0ZWRDb2RlKCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGl0KCdzaG91bGQgdHJhbnNmb3JtIHZhcmlhYmxlIGNhbGwgKGBpZGVudGlmaWVyYCBub2RlIG5hbWUpIGJlZm9yZSB2YXJpYWJsZSBkZWNsYXJhdGlvbiBpZiB0aGlzIGNhbGwgaXMgaW5zaWRlIGZ1bmN0aW9uIGJvZHknLCAoKSA9PiB7XG4gICAgICAgICAgICBhc3NlcnQubWF0Y2gob2JmdXNjYXRlZENvZGUsIGZ1bmN0aW9uQm9keVZhcmlhYmxlQ2FsbFJlZ0V4cCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGl0KCdzaG91bGQgdHJhbnNmb3JtIHZhcmlhYmxlIGNhbGwgKGBpZGVudGlmaWVyYCBub2RlIG5hbWUpIGJlZm9yZSB2YXJpYWJsZSBkZWNsYXJhdGlvbicsICgpID0+IHtcbiAgICAgICAgICAgIGFzc2VydC5tYXRjaChvYmZ1c2NhdGVkQ29kZSwgdmFyaWFibGVDYWxsQmVmb3JlRGVjbGFyYXRpb25SZWdFeHApO1xuICAgICAgICB9KTtcbiAgICB9KTtcblxuICAgIGRlc2NyaWJlKGB2YXJpYW50ICM2OiB2YXJpYWJsZSBjYWxscyBiZWZvcmUgdmFyaWFibGUgZGVjbGFyYXRpb24gd2hlbiBmdW5jdGlvbiBwYXJhbSBoYXMgdGhlIHNhbWUgbmFtZSBhcyB2YXJpYWJsZXMgbmFtZWAsICgpID0+IHtcbiAgICAgICAgY29uc3QgZnVuY3Rpb25QYXJhbUlkZW50aWZpZXJSZWdFeHA6IFJlZ0V4cCA9IC9mdW5jdGlvbiAqXzB4W2EtZjAtOV17NCw2fSAqXFwoKF8weFthLWYwLTldezQsNn0pXFwsKF8weFthLWYwLTldezQsNn0pXFwpICpcXHsvO1xuICAgICAgICBjb25zdCBpbm5lckZ1bmN0aW9uUGFyYW1JZGVudGlmaWVyUmVnRXhwOiBSZWdFeHAgPSAvZnVuY3Rpb24gXzB4W2EtZjAtOV17NCw2fSAqXFwoKF8weFthLWYwLTldezQsNn0pXFwpICpcXHsvO1xuICAgICAgICBjb25zdCBjb25zdHJ1Y3RvcklkZW50aWZpZXJSZWdFeHA6IFJlZ0V4cCA9IC9jb25zb2xlXFxbJ2xvZydcXF1cXCgoXzB4W2EtZjAtOV17NCw2fSlcXCkvO1xuICAgICAgICBjb25zdCBvYmplY3RJZGVudGlmaWVyUmVnRXhwOiBSZWdFeHAgPSAvcmV0dXJuXFx7J3QnOihfMHhbYS1mMC05XXs0LDZ9KVxcfS87XG4gICAgICAgIGNvbnN0IHZhcmlhYmxlRGVjbGFyYXRpb25JZGVudGlmaWVyUmVnRXhwOiBSZWdFeHAgPSAvdmFyICooXzB4W2EtZjAtOV17NCw2fSk7LztcblxuICAgICAgICBsZXQgb3V0ZXJGdW5jdGlvblBhcmFtSWRlbnRpZmllck5hbWU6IHN0cmluZ3xudWxsLFxuICAgICAgICAgICAgaW5uZXJGdW5jdGlvblBhcmFtSWRlbnRpZmllck5hbWU6IHN0cmluZ3xudWxsLFxuICAgICAgICAgICAgY29uc3RydWN0b3JJZGVudGlmaWVyTmFtZTogc3RyaW5nfG51bGwsXG4gICAgICAgICAgICBvYmplY3RJZGVudGlmaWVyTmFtZTogc3RyaW5nfG51bGwsXG4gICAgICAgICAgICB2YXJpYWJsZURlY2xhcmF0aW9uSWRlbnRpZmllck5hbWU6IHN0cmluZ3xudWxsO1xuXG4gICAgICAgIGJlZm9yZSgoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBjb2RlOiBzdHJpbmcgPSByZWFkRmlsZUFzU3RyaW5nKF9fZGlybmFtZSArICcvZml4dHVyZXMvdmFyaWFibGUtY2FsbC1iZWZvcmUtdmFyaWFibGUtZGVjbGFyYXRpb24tMi5qcycpO1xuICAgICAgICAgICAgY29uc3Qgb2JmdXNjYXRpb25SZXN1bHQ6IElPYmZ1c2NhdGlvblJlc3VsdCA9IEphdmFTY3JpcHRPYmZ1c2NhdG9yLm9iZnVzY2F0ZShcbiAgICAgICAgICAgICAgICBjb2RlLFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgLi4uTk9fQ1VTVE9NX05PREVTX1BSRVNFVFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBjb25zdCBvYmZ1c2NhdGVkQ29kZTogc3RyaW5nID0gb2JmdXNjYXRpb25SZXN1bHQuZ2V0T2JmdXNjYXRlZENvZGUoKTtcblxuICAgICAgICAgICAgb3V0ZXJGdW5jdGlvblBhcmFtSWRlbnRpZmllck5hbWUgPSBnZXRSZWdFeHBNYXRjaChvYmZ1c2NhdGVkQ29kZSwgZnVuY3Rpb25QYXJhbUlkZW50aWZpZXJSZWdFeHApO1xuICAgICAgICAgICAgaW5uZXJGdW5jdGlvblBhcmFtSWRlbnRpZmllck5hbWUgPSBnZXRSZWdFeHBNYXRjaChvYmZ1c2NhdGVkQ29kZSwgaW5uZXJGdW5jdGlvblBhcmFtSWRlbnRpZmllclJlZ0V4cCk7XG4gICAgICAgICAgICBjb25zdHJ1Y3RvcklkZW50aWZpZXJOYW1lID0gZ2V0UmVnRXhwTWF0Y2gob2JmdXNjYXRlZENvZGUsIGNvbnN0cnVjdG9ySWRlbnRpZmllclJlZ0V4cCk7XG4gICAgICAgICAgICBvYmplY3RJZGVudGlmaWVyTmFtZSA9IGdldFJlZ0V4cE1hdGNoKG9iZnVzY2F0ZWRDb2RlLCBvYmplY3RJZGVudGlmaWVyUmVnRXhwKTtcbiAgICAgICAgICAgIHZhcmlhYmxlRGVjbGFyYXRpb25JZGVudGlmaWVyTmFtZSA9IGdldFJlZ0V4cE1hdGNoKG9iZnVzY2F0ZWRDb2RlLCB2YXJpYWJsZURlY2xhcmF0aW9uSWRlbnRpZmllclJlZ0V4cCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGl0KCdtYXRjaCAjMTogc2hvdWxkXFwndCBuYW1lIHZhcmlhYmxlcyBpbnNpZGUgaW5uZXIgZnVuY3Rpb24gd2l0aCBuYW1lcyBmcm9tIG91dGVyIGZ1bmN0aW9uIHBhcmFtcycsICgpID0+IHtcbiAgICAgICAgICAgIGFzc2VydC5ub3RFcXVhbChvdXRlckZ1bmN0aW9uUGFyYW1JZGVudGlmaWVyTmFtZSwgY29uc3RydWN0b3JJZGVudGlmaWVyTmFtZSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGl0KCdtYXRjaCAjMjogc2hvdWxkXFwndCBuYW1lIHZhcmlhYmxlcyBpbnNpZGUgaW5uZXIgZnVuY3Rpb24gd2l0aCBuYW1lcyBmcm9tIG91dGVyIGZ1bmN0aW9uIHBhcmFtcycsICgpID0+IHtcbiAgICAgICAgICAgIGFzc2VydC5ub3RFcXVhbChvdXRlckZ1bmN0aW9uUGFyYW1JZGVudGlmaWVyTmFtZSwgaW5uZXJGdW5jdGlvblBhcmFtSWRlbnRpZmllck5hbWUpO1xuICAgICAgICB9KTtcblxuICAgICAgICBpdCgnbWF0Y2ggIzE6IHNob3VsZCBjb3JyZWN0IHRyYW5zZm9ybSB2YXJpYWJsZXMgaW5zaWRlIG91dGVyIGZ1bmN0aW9uIGJvZHknLCAoKSA9PiB7XG4gICAgICAgICAgICBhc3NlcnQuZXF1YWwob3V0ZXJGdW5jdGlvblBhcmFtSWRlbnRpZmllck5hbWUsIG9iamVjdElkZW50aWZpZXJOYW1lKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaXQoJ21hdGNoICMyOiBzaG91bGQgY29ycmVjdCB0cmFuc2Zvcm0gdmFyaWFibGVzIGluc2lkZSBvdXRlciBmdW5jdGlvbiBib2R5JywgKCkgPT4ge1xuICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKG91dGVyRnVuY3Rpb25QYXJhbUlkZW50aWZpZXJOYW1lLCB2YXJpYWJsZURlY2xhcmF0aW9uSWRlbnRpZmllck5hbWUpO1xuICAgICAgICB9KTtcblxuICAgICAgICBpdCgnc2hvdWxkIGNvcnJlY3QgdHJhbnNmb3JtIHZhcmlhYmxlcyBpbnNpZGUgaW5uZXIgZnVuY3Rpb24gYm9keScsICgpID0+IHtcbiAgICAgICAgICAgIGFzc2VydC5lcXVhbChpbm5lckZ1bmN0aW9uUGFyYW1JZGVudGlmaWVyTmFtZSwgY29uc3RydWN0b3JJZGVudGlmaWVyTmFtZSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGl0KCdzaG91bGQga2VlcCBlcXVhbCBuYW1lcyBhZnRlciB0cmFuc2Zvcm1hdGlvbiBmb3IgdmFyaWFibGVzIHdpdGggc2FtZSBuYW1lcycsICgpID0+IHtcbiAgICAgICAgICAgIGFzc2VydC5lcXVhbCh2YXJpYWJsZURlY2xhcmF0aW9uSWRlbnRpZmllck5hbWUsIG9iamVjdElkZW50aWZpZXJOYW1lKTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBkZXNjcmliZShgdmFyaWFudCAjNzogdmFyaWFibGUgY2FsbHMgYmVmb3JlIHZhcmlhYmxlIGRlY2xhcmF0aW9uIHdoZW4gY2F0Y2ggY2xhdXNlIHBhcmFtIGhhcyB0aGUgc2FtZSBuYW1lIGFzIHZhcmlhYmxlcyBuYW1lYCwgKCkgPT4ge1xuICAgICAgICBjb25zdCBjYXRjaENsYXVzZVBhcmFtSWRlbnRpZmllclJlZ0V4cDogUmVnRXhwID0gL2NhdGNoICpcXCgoXzB4W2EtZjAtOV17NCw2fSlcXCkgKlxcey87XG4gICAgICAgIGNvbnN0IGlubmVyRnVuY3Rpb25QYXJhbUlkZW50aWZpZXJSZWdFeHA6IFJlZ0V4cCA9IC9mdW5jdGlvbiBfMHhbYS1mMC05XXs0LDZ9ICpcXCgoXzB4W2EtZjAtOV17NCw2fSlcXCkgKlxcey87XG4gICAgICAgIGNvbnN0IGNvbnN0cnVjdG9ySWRlbnRpZmllclJlZ0V4cDogUmVnRXhwID0gL2NvbnNvbGVcXFsnbG9nJ1xcXVxcKChfMHhbYS1mMC05XXs0LDZ9KVxcKS87XG4gICAgICAgIGNvbnN0IG9iamVjdElkZW50aWZpZXJSZWdFeHA6IFJlZ0V4cCA9IC9yZXR1cm5cXHsndCc6KF8weFthLWYwLTldezQsNn0pXFx9LztcbiAgICAgICAgY29uc3QgdmFyaWFibGVEZWNsYXJhdGlvbklkZW50aWZpZXJSZWdFeHA6IFJlZ0V4cCA9IC92YXIgKihfMHhbYS1mMC05XXs0LDZ9KTsvO1xuXG4gICAgICAgIGxldCBjYXRjaENsYXVzZVBhcmFtSWRlbnRpZmllck5hbWU6IHN0cmluZ3xudWxsLFxuICAgICAgICAgICAgaW5uZXJGdW5jdGlvblBhcmFtSWRlbnRpZmllck5hbWU6IHN0cmluZ3xudWxsLFxuICAgICAgICAgICAgY29uc3RydWN0b3JJZGVudGlmaWVyTmFtZTogc3RyaW5nfG51bGwsXG4gICAgICAgICAgICBvYmplY3RJZGVudGlmaWVyTmFtZTogc3RyaW5nfG51bGwsXG4gICAgICAgICAgICB2YXJpYWJsZURlY2xhcmF0aW9uSWRlbnRpZmllck5hbWU6IHN0cmluZ3xudWxsO1xuXG4gICAgICAgIGJlZm9yZSgoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBjb2RlOiBzdHJpbmcgPSByZWFkRmlsZUFzU3RyaW5nKF9fZGlybmFtZSArICcvZml4dHVyZXMvdmFyaWFibGUtY2FsbC1iZWZvcmUtdmFyaWFibGUtZGVjbGFyYXRpb24tMy5qcycpO1xuICAgICAgICAgICAgY29uc3Qgb2JmdXNjYXRpb25SZXN1bHQ6IElPYmZ1c2NhdGlvblJlc3VsdCA9IEphdmFTY3JpcHRPYmZ1c2NhdG9yLm9iZnVzY2F0ZShcbiAgICAgICAgICAgICAgICBjb2RlLFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgLi4uTk9fQ1VTVE9NX05PREVTX1BSRVNFVFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBjb25zdCBvYmZ1c2NhdGVkQ29kZTogc3RyaW5nID0gb2JmdXNjYXRpb25SZXN1bHQuZ2V0T2JmdXNjYXRlZENvZGUoKTtcblxuICAgICAgICAgICAgY2F0Y2hDbGF1c2VQYXJhbUlkZW50aWZpZXJOYW1lID0gZ2V0UmVnRXhwTWF0Y2gob2JmdXNjYXRlZENvZGUsIGNhdGNoQ2xhdXNlUGFyYW1JZGVudGlmaWVyUmVnRXhwKTtcbiAgICAgICAgICAgIGlubmVyRnVuY3Rpb25QYXJhbUlkZW50aWZpZXJOYW1lID0gZ2V0UmVnRXhwTWF0Y2gob2JmdXNjYXRlZENvZGUsIGlubmVyRnVuY3Rpb25QYXJhbUlkZW50aWZpZXJSZWdFeHApO1xuICAgICAgICAgICAgY29uc3RydWN0b3JJZGVudGlmaWVyTmFtZSA9IGdldFJlZ0V4cE1hdGNoKG9iZnVzY2F0ZWRDb2RlLCBjb25zdHJ1Y3RvcklkZW50aWZpZXJSZWdFeHApO1xuICAgICAgICAgICAgb2JqZWN0SWRlbnRpZmllck5hbWUgPSBnZXRSZWdFeHBNYXRjaChvYmZ1c2NhdGVkQ29kZSwgb2JqZWN0SWRlbnRpZmllclJlZ0V4cCk7XG4gICAgICAgICAgICB2YXJpYWJsZURlY2xhcmF0aW9uSWRlbnRpZmllck5hbWUgPSBnZXRSZWdFeHBNYXRjaChvYmZ1c2NhdGVkQ29kZSwgdmFyaWFibGVEZWNsYXJhdGlvbklkZW50aWZpZXJSZWdFeHApO1xuICAgICAgICB9KTtcblxuICAgICAgICBpdCgnbWF0Y2ggIzE6IHNob3VsZFxcJ3QgbmFtZSB2YXJpYWJsZXMgaW5zaWRlIGlubmVyIGZ1bmN0aW9uIHdpdGggbmFtZXMgZnJvbSBjYXRjaCBjbGF1c2UgcGFyYW0nLCAoKSA9PiB7XG4gICAgICAgICAgICBhc3NlcnQubm90RXF1YWwoY2F0Y2hDbGF1c2VQYXJhbUlkZW50aWZpZXJOYW1lLCBjb25zdHJ1Y3RvcklkZW50aWZpZXJOYW1lKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaXQoJ21hdGNoICMyOiBzaG91bGRcXCd0IG5hbWUgdmFyaWFibGVzIGluc2lkZSBpbm5lciBmdW5jdGlvbiB3aXRoIG5hbWVzIGZyb20gY2F0Y2ggY2xhdXNlIHBhcmFtJywgKCkgPT4ge1xuICAgICAgICAgICAgYXNzZXJ0Lm5vdEVxdWFsKGNhdGNoQ2xhdXNlUGFyYW1JZGVudGlmaWVyTmFtZSwgaW5uZXJGdW5jdGlvblBhcmFtSWRlbnRpZmllck5hbWUpO1xuICAgICAgICB9KTtcblxuICAgICAgICBpdCgnZXF1YWwgIzE6IHNob3VsZCBjb3JyZWN0IHRyYW5zZm9ybSB2YXJpYWJsZXMgaW5zaWRlIGNhdGNoIGNsYXVzZSBib2R5JywgKCkgPT4ge1xuICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKGNhdGNoQ2xhdXNlUGFyYW1JZGVudGlmaWVyTmFtZSwgb2JqZWN0SWRlbnRpZmllck5hbWUpO1xuICAgICAgICB9KTtcblxuICAgICAgICBpdCgnZXF1YWwgIzI6IHNob3VsZCBjb3JyZWN0IHRyYW5zZm9ybSB2YXJpYWJsZXMgaW5zaWRlIGNhdGNoIGNsYXVzZSBib2R5JywgKCkgPT4ge1xuICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKGNhdGNoQ2xhdXNlUGFyYW1JZGVudGlmaWVyTmFtZSwgdmFyaWFibGVEZWNsYXJhdGlvbklkZW50aWZpZXJOYW1lKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaXQoJ3Nob3VsZCBjb3JyZWN0IHRyYW5zZm9ybSB2YXJpYWJsZXMgaW5zaWRlIGlubmVyIGZ1bmN0aW9uIGJvZHknLCAoKSA9PiB7XG4gICAgICAgICAgICBhc3NlcnQuZXF1YWwoaW5uZXJGdW5jdGlvblBhcmFtSWRlbnRpZmllck5hbWUsIGNvbnN0cnVjdG9ySWRlbnRpZmllck5hbWUpO1xuICAgICAgICB9KTtcblxuICAgICAgICBpdCgnc2hvdWxkIGtlZXAgZXF1YWwgbmFtZXMgYWZ0ZXIgdHJhbnNmb3JtYXRpb24gZm9yIHZhcmlhYmxlcyB3aXRoIHNhbWUgbmFtZXMnLCAoKSA9PiB7XG4gICAgICAgICAgICBhc3NlcnQuZXF1YWwodmFyaWFibGVEZWNsYXJhdGlvbklkZW50aWZpZXJOYW1lLCBvYmplY3RJZGVudGlmaWVyTmFtZSk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgZGVzY3JpYmUoJ3ZhcmlhbnQgIzg6IHdyb25nIHJlcGxhY2VtZW50JywgKCkgPT4ge1xuICAgICAgICBkZXNjcmliZSgndmFyaWFudCAjMTogcHJvcGVydHkgbm9kZSBpZGVudGlmaWVyJywgKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcmVnRXhwOiBSZWdFeHAgPSAvdmFyIF8weChbYS1mMC05XSl7NCw2fSAqPSAqXFx7J3Rlc3QvO1xuXG4gICAgICAgICAgICBsZXQgb2JmdXNjYXRlZENvZGU6IHN0cmluZztcblxuICAgICAgICAgICAgYmVmb3JlKCgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBjb2RlOiBzdHJpbmcgPSByZWFkRmlsZUFzU3RyaW5nKF9fZGlybmFtZSArICcvZml4dHVyZXMvcHJvcGVydHktaWRlbnRpZmllci5qcycpO1xuICAgICAgICAgICAgICAgIGNvbnN0IG9iZnVzY2F0aW9uUmVzdWx0OiBJT2JmdXNjYXRpb25SZXN1bHQgPSBKYXZhU2NyaXB0T2JmdXNjYXRvci5vYmZ1c2NhdGUoXG4gICAgICAgICAgICAgICAgICAgIGNvZGUsXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLk5PX0NVU1RPTV9OT0RFU19QUkVTRVRcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgICBvYmZ1c2NhdGVkQ29kZSA9IG9iZnVzY2F0aW9uUmVzdWx0LmdldE9iZnVzY2F0ZWRDb2RlKCk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaXQoJ3Nob3VsZG5cXCd0IHJlcGxhY2UgcHJvcGVydHkgbm9kZSBpZGVudGlmaWVyJywgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGFzc2VydC5tYXRjaChvYmZ1c2NhdGVkQ29kZSwgcmVnRXhwKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcblxuICAgICAgICBkZXNjcmliZSgndmFyaWFudCAjMjogY29tcHV0ZWQgbWVtYmVyIGV4cHJlc3Npb24gaWRlbnRpZmllcicsICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHJlZ0V4cDogUmVnRXhwID0gL18weChbYS1mMC05XSl7NCw2fVxcWyd0ZXN0J1xcXS87XG5cbiAgICAgICAgICAgIGxldCBvYmZ1c2NhdGVkQ29kZTogc3RyaW5nO1xuXG4gICAgICAgICAgICBiZWZvcmUoKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvZGU6IHN0cmluZyA9IHJlYWRGaWxlQXNTdHJpbmcoX19kaXJuYW1lICsgJy9maXh0dXJlcy9tZW1iZXItZXhwcmVzc2lvbi1pZGVudGlmaWVyLmpzJyk7XG4gICAgICAgICAgICAgICAgY29uc3Qgb2JmdXNjYXRpb25SZXN1bHQ6IElPYmZ1c2NhdGlvblJlc3VsdCA9IEphdmFTY3JpcHRPYmZ1c2NhdG9yLm9iZnVzY2F0ZShcbiAgICAgICAgICAgICAgICAgICAgY29kZSxcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgLi4uTk9fQ1VTVE9NX05PREVTX1BSRVNFVFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgICAgIG9iZnVzY2F0ZWRDb2RlID0gb2JmdXNjYXRpb25SZXN1bHQuZ2V0T2JmdXNjYXRlZENvZGUoKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpdCgnc2hvdWxkblxcJ3QgcmVwbGFjZSBjb21wdXRlZCBtZW1iZXIgZXhwcmVzc2lvbiBpZGVudGlmaWVyJywgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGFzc2VydC5tYXRjaChvYmZ1c2NhdGVkQ29kZSwgcmVnRXhwKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9KTtcblxuICAgIGRlc2NyaWJlKCd2YXJpYW50ICM5OiBvYmplY3QgcGF0dGVybiBhcyB2YXJpYWJsZSBkZWNsYXJhdG9yJywgKCkgPT4ge1xuICAgICAgICBjb25zdCBvYmplY3RQYXR0ZXJuVmFyaWFibGVEZWNsYXJhdG9yUmVnRXhwOiBSZWdFeHAgPSAvdmFyICpcXHsgKmJhciAqXFx9ICo9ICpcXHsgKidiYXInICo6IConZm9vJyAqXFx9Oy87XG4gICAgICAgIGNvbnN0IHZhcmlhYmxlVXNhZ2VSZWdFeHA6IFJlZ0V4cCA9IC9jb25zb2xlXFxbJ2xvZydcXF1cXChiYXJcXCk7LztcblxuICAgICAgICBsZXQgb2JmdXNjYXRlZENvZGU6IHN0cmluZztcblxuICAgICAgICBiZWZvcmUoKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgY29kZTogc3RyaW5nID0gcmVhZEZpbGVBc1N0cmluZyhfX2Rpcm5hbWUgKyAnL2ZpeHR1cmVzL29iamVjdC1wYXR0ZXJuLmpzJyk7XG4gICAgICAgICAgICBjb25zdCBvYmZ1c2NhdGlvblJlc3VsdDogSU9iZnVzY2F0aW9uUmVzdWx0ID0gSmF2YVNjcmlwdE9iZnVzY2F0b3Iub2JmdXNjYXRlKFxuICAgICAgICAgICAgICAgIGNvZGUsXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAuLi5OT19DVVNUT01fTk9ERVNfUFJFU0VUXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgb2JmdXNjYXRlZENvZGUgPSBvYmZ1c2NhdGlvblJlc3VsdC5nZXRPYmZ1c2NhdGVkQ29kZSgpO1xuICAgICAgICB9KTtcblxuICAgICAgICBpdCgnbWF0Y2ggIzE6IHNob3VsZG5cXCd0IHRyYW5zZm9ybSBvYmplY3QgcGF0dGVybiB2YXJpYWJsZSBkZWNsYXJhdG9yJywgKCkgPT4ge1xuICAgICAgICAgICAgYXNzZXJ0Lm1hdGNoKG9iZnVzY2F0ZWRDb2RlLCBvYmplY3RQYXR0ZXJuVmFyaWFibGVEZWNsYXJhdG9yUmVnRXhwKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaXQoJ21hdGNoICMyOiBzaG91bGRuXFwndCB0cmFuc2Zvcm0gb2JqZWN0IHBhdHRlcm4gdmFyaWFibGUgZGVjbGFyYXRvcicsICgpID0+IHtcbiAgICAgICAgICAgIGFzc2VydC5tYXRjaChvYmZ1c2NhdGVkQ29kZSwgdmFyaWFibGVVc2FnZVJlZ0V4cCk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgZGVzY3JpYmUoJ3ZhcmlhbnQgIzEwOiBhcnJheSBwYXR0ZXJuIGFzIHZhcmlhYmxlIGRlY2xhcmF0b3InLCAoKSA9PiB7XG4gICAgICAgIGNvbnN0IG9iamVjdFBhdHRlcm5WYXJpYWJsZURlY2xhcmF0b3JSZWdFeHA6IFJlZ0V4cCA9IC92YXIgKlxcWyAqKF8weChbYS1mMC05XSl7NCw2fSksICooXzB4KFthLWYwLTldKXs0LDZ9KSAqXFxdICo9ICpcXFsweDEsICoweDJcXF07LztcbiAgICAgICAgY29uc3QgdmFyaWFibGVVc2FnZVJlZ0V4cDogUmVnRXhwID0gL2NvbnNvbGVcXFsnbG9nJ1xcXVxcKChfMHgoW2EtZjAtOV0pezQsNn0pLCAqKF8weChbYS1mMC05XSl7NCw2fSlcXCk7LztcblxuICAgICAgICBsZXQgb2JmdXNjYXRlZENvZGU6IHN0cmluZyxcbiAgICAgICAgICAgIG9iamVjdFBhdHRlcm5JZGVudGlmaWVyTmFtZTE6IHN0cmluZyxcbiAgICAgICAgICAgIG9iamVjdFBhdHRlcm5JZGVudGlmaWVyTmFtZTI6IHN0cmluZyxcbiAgICAgICAgICAgIGlkZW50aWZpZXJOYW1lMTogc3RyaW5nLFxuICAgICAgICAgICAgaWRlbnRpZmllck5hbWUyOiBzdHJpbmc7XG5cbiAgICAgICAgYmVmb3JlKCgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGNvZGU6IHN0cmluZyA9IHJlYWRGaWxlQXNTdHJpbmcoX19kaXJuYW1lICsgJy9maXh0dXJlcy9hcnJheS1wYXR0ZXJuLmpzJyk7XG4gICAgICAgICAgICBjb25zdCBvYmZ1c2NhdGlvblJlc3VsdDogSU9iZnVzY2F0aW9uUmVzdWx0ID0gSmF2YVNjcmlwdE9iZnVzY2F0b3Iub2JmdXNjYXRlKFxuICAgICAgICAgICAgICAgIGNvZGUsXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAuLi5OT19DVVNUT01fTk9ERVNfUFJFU0VUXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgb2JmdXNjYXRlZENvZGUgPSBvYmZ1c2NhdGlvblJlc3VsdC5nZXRPYmZ1c2NhdGVkQ29kZSgpO1xuXG4gICAgICAgICAgICBvYmplY3RQYXR0ZXJuSWRlbnRpZmllck5hbWUxID0gZ2V0UmVnRXhwTWF0Y2gob2JmdXNjYXRlZENvZGUsIG9iamVjdFBhdHRlcm5WYXJpYWJsZURlY2xhcmF0b3JSZWdFeHApO1xuICAgICAgICAgICAgb2JqZWN0UGF0dGVybklkZW50aWZpZXJOYW1lMiA9IGdldFJlZ0V4cE1hdGNoKG9iZnVzY2F0ZWRDb2RlLCBvYmplY3RQYXR0ZXJuVmFyaWFibGVEZWNsYXJhdG9yUmVnRXhwLCAxKTtcbiAgICAgICAgICAgIGlkZW50aWZpZXJOYW1lMSA9IGdldFJlZ0V4cE1hdGNoKG9iZnVzY2F0ZWRDb2RlLCB2YXJpYWJsZVVzYWdlUmVnRXhwKTtcbiAgICAgICAgICAgIGlkZW50aWZpZXJOYW1lMiA9IGdldFJlZ0V4cE1hdGNoKG9iZnVzY2F0ZWRDb2RlLCB2YXJpYWJsZVVzYWdlUmVnRXhwLCAxKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaXQoJ21hdGNoICMxOiBzaG91bGQgdHJhbnNmb3JtIGFycmF5IHBhdHRlcm4gdmFyaWFibGUgZGVjbGFyYXRvcicsICgpID0+IHtcbiAgICAgICAgICAgIGFzc2VydC5tYXRjaChvYmZ1c2NhdGVkQ29kZSwgb2JqZWN0UGF0dGVyblZhcmlhYmxlRGVjbGFyYXRvclJlZ0V4cCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGl0KCdtYXRjaCAjMjogc2hvdWxkIHRyYW5zZm9ybSBhcnJheSBwYXR0ZXJuIHZhcmlhYmxlIGRlY2xhcmF0b3InLCAoKSA9PiB7XG4gICAgICAgICAgICBhc3NlcnQubWF0Y2gob2JmdXNjYXRlZENvZGUsIHZhcmlhYmxlVXNhZ2VSZWdFeHApO1xuICAgICAgICB9KTtcblxuICAgICAgICBpdCgnZXF1YWwgIzE6IHNob3VsZCBrZWVwIHNhbWUgaWRlbnRpZmllciBuYW1lcyBzYW1lIGZvciBpZGVudGlmaWVycyBpbiB2YXJpYWJsZSBkZWNsYXJhdGlvbiBhbmQgYWZ0ZXIgdmFyaWFibGUgZGVjbGFyYXRpb24nLCAoKSA9PiB7XG4gICAgICAgICAgICBhc3NlcnQuZXF1YWwob2JqZWN0UGF0dGVybklkZW50aWZpZXJOYW1lMSwgaWRlbnRpZmllck5hbWUxKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaXQoJ2VxdWFsICMyOiBzaG91bGQga2VlcCBzYW1lIGlkZW50aWZpZXIgbmFtZXMgc2FtZSBmb3IgaWRlbnRpZmllcnMgaW4gdmFyaWFibGUgZGVjbGFyYXRpb24gYW5kIGFmdGVyIHZhcmlhYmxlIGRlY2xhcmF0aW9uJywgKCkgPT4ge1xuICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKG9iamVjdFBhdHRlcm5JZGVudGlmaWVyTmFtZTIsIGlkZW50aWZpZXJOYW1lMik7XG4gICAgICAgIH0pO1xuICAgIH0pO1xufSk7XG4iXX0=