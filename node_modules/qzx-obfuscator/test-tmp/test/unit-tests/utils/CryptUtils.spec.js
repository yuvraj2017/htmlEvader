"use strict";

var _slicedToArray = (function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; })();

Object.defineProperty(exports, "__esModule", { value: true });
var chai_1 = require("chai");
var ServiceIdentifiers_1 = require("../../../src/container/ServiceIdentifiers");
var InversifyContainerFacade_1 = require("../../../src/container/InversifyContainerFacade");
describe('CryptUtils', function () {
    var cryptUtils = void 0;
    before(function () {
        var inversifyContainerFacade = new InversifyContainerFacade_1.InversifyContainerFacade();
        inversifyContainerFacade.load('', {});
        cryptUtils = inversifyContainerFacade.get(ServiceIdentifiers_1.ServiceIdentifiers.ICryptUtils);
    });
    describe('btoa (string: string): string', function () {
        var expectedString = 'c3RyaW5n';
        var string = void 0;
        before(function () {
            string = cryptUtils.btoa('string');
        });
        it('should create a base-64 encoded string from a given string', function () {
            chai_1.assert.equal(string, expectedString);
        });
    });
    describe('hideString (str: string, length: number): [string, string]', function () {
        var originalString = 'example.com';
        var hiddenStringLength = 30;
        var hiddenString = void 0,
            diffString = void 0;
        before(function () {
            var _cryptUtils$hideStrin = cryptUtils.hideString(originalString, hiddenStringLength);

            var _cryptUtils$hideStrin2 = _slicedToArray(_cryptUtils$hideStrin, 2);

            hiddenString = _cryptUtils$hideStrin2[0];
            diffString = _cryptUtils$hideStrin2[1];
        });
        describe('hidden string length check', function () {
            var originalStringActualLength = void 0,
                hiddenStringActualLength = void 0;
            before(function () {
                originalStringActualLength = originalString.length;
                hiddenStringActualLength = hiddenString.length;
            });
            it('should create hidden string with length equal or bigger than given length', function () {
                chai_1.assert.isTrue(hiddenStringActualLength > originalStringActualLength);
            });
        });
        describe('hidden string content', function () {
            var hiddenStringWithoutDiff = void 0;
            before(function () {
                var regExp = new RegExp("[" + diffString + "]", 'g');
                hiddenStringWithoutDiff = hiddenString.replace(regExp, '');
            });
            it('should return a hidden string with the original string within', function () {
                chai_1.assert.equal(hiddenStringWithoutDiff, originalString);
            });
        });
    });
    describe('rc4 (string: string, key: string): string', function () {
        var string = 'test';
        var key = 'key';
        var encodedString = void 0,
            decodedString = void 0;
        before(function () {
            encodedString = cryptUtils.rc4(string, key);
            decodedString = cryptUtils.rc4(encodedString, key);
        });
        it('should encode string using the rc4 algorithm', function () {
            chai_1.assert.notEqual(encodedString, string);
        });
        it('should encode and successfully decode string using the rc4 algorithm', function () {
            chai_1.assert.equal(decodedString, string);
        });
    });
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQ3J5cHRVdGlscy5zcGVjLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vdGVzdC91bml0LXRlc3RzL3V0aWxzL0NyeXB0VXRpbHMuc3BlYy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7OztBQUFBLHFCQUE4QjtBQUU5QixtQ0FBK0U7QUFLL0UseUNBQTJGO0FBRTNGLEFBQVEsU0FBQyxBQUFZLGNBQUU7QUFDbkIsUUFBSSxBQUF1QixBQUFDO0FBRTVCLEFBQU0sV0FBQztBQUNILFlBQU0sQUFBd0IsMkJBQThCLElBQUksMkJBQXdCLEFBQUUsQUFBQztBQUUzRixBQUF3QixpQ0FBQyxBQUFJLEtBQUMsQUFBRSxJQUFFLEFBQUUsQUFBQyxBQUFDO0FBQ3RDLEFBQVUscUJBQUcsQUFBd0IseUJBQUMsQUFBRyxJQUFjLHFCQUFrQixtQkFBQyxBQUFXLEFBQUMsQUFBQyxBQUMzRjtBQUFDLEFBQUMsQUFBQztBQUVILEFBQVEsYUFBQyxBQUErQixpQ0FBRTtBQUN0QyxZQUFNLEFBQWMsaUJBQVcsQUFBVSxBQUFDO0FBRTFDLFlBQUksQUFBYyxBQUFDO0FBRW5CLEFBQU0sZUFBQztBQUNILEFBQU0scUJBQUcsQUFBVSxXQUFDLEFBQUksS0FBQyxBQUFRLEFBQUMsQUFBQyxBQUN2QztBQUFDLEFBQUMsQUFBQztBQUVILEFBQUUsV0FBQyxBQUE0RCw4REFBRTtBQUM3RCxtQkFBTSxPQUFDLEFBQUssTUFBQyxBQUFNLFFBQUUsQUFBYyxBQUFDLEFBQUMsQUFDekM7QUFBQyxBQUFDLEFBQUMsQUFDUDtBQUFDLEFBQUMsQUFBQztBQUVILEFBQVEsYUFBQyxBQUE0RCw4REFBRTtBQUNuRSxZQUFNLEFBQWMsaUJBQVcsQUFBYSxBQUFDO0FBQzdDLFlBQU0sQUFBa0IscUJBQVcsQUFBRSxBQUFDO0FBRXRDLFlBQUksQUFBb0I7WUFDcEIsQUFBa0IsQUFBQztBQUV2QixBQUFNLGVBQUM7QUFDSCx3Q0FBNkIsQUFBVSxXQUFDLEFBQVUsV0FBQyxBQUFjLGdCQUFFLEFBQWtCLEFBQUMsQUFBQyxBQUMzRjs7OztBQURLLEFBQVk7QUFBRSxBQUFVLEFBQUM7QUFDN0IsQUFBQyxBQUFDO0FBRUgsQUFBUSxpQkFBQyxBQUE0Qiw4QkFBRTtBQUNuQyxnQkFBSSxBQUFrQztnQkFDbEMsQUFBZ0MsQUFBQztBQUVyQyxBQUFNLG1CQUFDO0FBQ0gsQUFBMEIsNkNBQUcsQUFBYyxlQUFDLEFBQU0sQUFBQztBQUNuRCxBQUF3QiwyQ0FBRyxBQUFZLGFBQUMsQUFBTSxBQUFDLEFBQ25EO0FBQUMsQUFBQyxBQUFDO0FBRUgsQUFBRSxlQUFDLEFBQTJFLDZFQUFFO0FBQzVFLHVCQUFNLE9BQUMsQUFBTSxPQUFDLEFBQXdCLDJCQUFHLEFBQTBCLEFBQUMsQUFBQyxBQUN6RTtBQUFDLEFBQUMsQUFBQyxBQUNQO0FBQUMsQUFBQyxBQUFDO0FBRUgsQUFBUSxpQkFBQyxBQUF1Qix5QkFBRTtBQUM5QixnQkFBSSxBQUErQixBQUFDO0FBRXBDLEFBQU0sbUJBQUM7QUFDSCxvQkFBTSxBQUFNLFNBQVcsSUFBSSxBQUFNLEFBQUMsYUFBSSxBQUFVLEFBQUcsa0JBQUUsQUFBRyxBQUFDLEFBQUM7QUFFMUQsQUFBdUIsMENBQUcsQUFBWSxhQUFDLEFBQU8sUUFBQyxBQUFNLFFBQUUsQUFBRSxBQUFDLEFBQUMsQUFDL0Q7QUFBQyxBQUFDLEFBQUM7QUFFSCxBQUFFLGVBQUMsQUFBK0QsaUVBQUU7QUFDaEUsdUJBQU0sT0FBQyxBQUFLLE1BQUMsQUFBdUIseUJBQUUsQUFBYyxBQUFDLEFBQUMsQUFDMUQ7QUFBQyxBQUFDLEFBQUMsQUFDUDtBQUFDLEFBQUMsQUFBQyxBQUNQO0FBQUMsQUFBQyxBQUFDO0FBRUgsQUFBUSxhQUFDLEFBQTJDLDZDQUFFO0FBQ2xELFlBQU0sQUFBTSxTQUFXLEFBQU0sQUFBQztBQUM5QixZQUFNLEFBQUcsTUFBVyxBQUFLLEFBQUM7QUFFMUIsWUFBSSxBQUFxQjtZQUNyQixBQUFxQixBQUFDO0FBRTFCLEFBQU0sZUFBQztBQUNILEFBQWEsNEJBQUcsQUFBVSxXQUFDLEFBQUcsSUFBQyxBQUFNLFFBQUUsQUFBRyxBQUFDLEFBQUM7QUFDNUMsQUFBYSw0QkFBRyxBQUFVLFdBQUMsQUFBRyxJQUFDLEFBQWEsZUFBRSxBQUFHLEFBQUMsQUFBQyxBQUN2RDtBQUFDLEFBQUMsQUFBQztBQUVILEFBQUUsV0FBQyxBQUE4QyxnREFBRTtBQUMvQyxtQkFBTSxPQUFDLEFBQVEsU0FBQyxBQUFhLGVBQUUsQUFBTSxBQUFDLEFBQUMsQUFDM0M7QUFBQyxBQUFDLEFBQUM7QUFFSCxBQUFFLFdBQUMsQUFBc0Usd0VBQUU7QUFDdkUsbUJBQU0sT0FBQyxBQUFLLE1BQUMsQUFBYSxlQUFFLEFBQU0sQUFBQyxBQUFDLEFBQ3hDO0FBQUMsQUFBQyxBQUFDLEFBQ1A7QUFBQyxBQUFDLEFBQUMsQUFDUDtBQUFDLEFBQUMsQUFBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGFzc2VydCB9IGZyb20gJ2NoYWknO1xuXG5pbXBvcnQgeyBTZXJ2aWNlSWRlbnRpZmllcnMgfSBmcm9tICcuLi8uLi8uLi9zcmMvY29udGFpbmVyL1NlcnZpY2VJZGVudGlmaWVycyc7XG5cbmltcG9ydCB7IElDcnlwdFV0aWxzIH0gZnJvbSAnLi4vLi4vLi4vc3JjL2ludGVyZmFjZXMvdXRpbHMvSUNyeXB0VXRpbHMnO1xuaW1wb3J0IHsgSUludmVyc2lmeUNvbnRhaW5lckZhY2FkZSB9IGZyb20gJy4uLy4uLy4uL3NyYy9pbnRlcmZhY2VzL2NvbnRhaW5lci9JSW52ZXJzaWZ5Q29udGFpbmVyRmFjYWRlJztcblxuaW1wb3J0IHsgSW52ZXJzaWZ5Q29udGFpbmVyRmFjYWRlIH0gZnJvbSAnLi4vLi4vLi4vc3JjL2NvbnRhaW5lci9JbnZlcnNpZnlDb250YWluZXJGYWNhZGUnO1xuXG5kZXNjcmliZSgnQ3J5cHRVdGlscycsICgpID0+IHtcbiAgICBsZXQgY3J5cHRVdGlsczogSUNyeXB0VXRpbHM7XG5cbiAgICBiZWZvcmUoKCkgPT4ge1xuICAgICAgICBjb25zdCBpbnZlcnNpZnlDb250YWluZXJGYWNhZGU6IElJbnZlcnNpZnlDb250YWluZXJGYWNhZGUgPSBuZXcgSW52ZXJzaWZ5Q29udGFpbmVyRmFjYWRlKCk7XG5cbiAgICAgICAgaW52ZXJzaWZ5Q29udGFpbmVyRmFjYWRlLmxvYWQoJycsIHt9KTtcbiAgICAgICAgY3J5cHRVdGlscyA9IGludmVyc2lmeUNvbnRhaW5lckZhY2FkZS5nZXQ8SUNyeXB0VXRpbHM+KFNlcnZpY2VJZGVudGlmaWVycy5JQ3J5cHRVdGlscyk7XG4gICAgfSk7XG5cbiAgICBkZXNjcmliZSgnYnRvYSAoc3RyaW5nOiBzdHJpbmcpOiBzdHJpbmcnLCAoKSA9PiB7XG4gICAgICAgIGNvbnN0IGV4cGVjdGVkU3RyaW5nOiBzdHJpbmcgPSAnYzNSeWFXNW4nO1xuXG4gICAgICAgIGxldCBzdHJpbmc6IHN0cmluZztcblxuICAgICAgICBiZWZvcmUoKCkgPT4ge1xuICAgICAgICAgICAgc3RyaW5nID0gY3J5cHRVdGlscy5idG9hKCdzdHJpbmcnKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaXQoJ3Nob3VsZCBjcmVhdGUgYSBiYXNlLTY0IGVuY29kZWQgc3RyaW5nIGZyb20gYSBnaXZlbiBzdHJpbmcnLCAoKSA9PiB7XG4gICAgICAgICAgICBhc3NlcnQuZXF1YWwoc3RyaW5nLCBleHBlY3RlZFN0cmluZyk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgZGVzY3JpYmUoJ2hpZGVTdHJpbmcgKHN0cjogc3RyaW5nLCBsZW5ndGg6IG51bWJlcik6IFtzdHJpbmcsIHN0cmluZ10nLCAoKSA9PiB7XG4gICAgICAgIGNvbnN0IG9yaWdpbmFsU3RyaW5nOiBzdHJpbmcgPSAnZXhhbXBsZS5jb20nO1xuICAgICAgICBjb25zdCBoaWRkZW5TdHJpbmdMZW5ndGg6IG51bWJlciA9IDMwO1xuXG4gICAgICAgIGxldCBoaWRkZW5TdHJpbmc6IHN0cmluZyxcbiAgICAgICAgICAgIGRpZmZTdHJpbmc6IHN0cmluZztcblxuICAgICAgICBiZWZvcmUoKCkgPT4ge1xuICAgICAgICAgICAgW2hpZGRlblN0cmluZywgZGlmZlN0cmluZ10gPSBjcnlwdFV0aWxzLmhpZGVTdHJpbmcob3JpZ2luYWxTdHJpbmcsIGhpZGRlblN0cmluZ0xlbmd0aCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGRlc2NyaWJlKCdoaWRkZW4gc3RyaW5nIGxlbmd0aCBjaGVjaycsICgpID0+IHtcbiAgICAgICAgICAgIGxldCBvcmlnaW5hbFN0cmluZ0FjdHVhbExlbmd0aDogbnVtYmVyLFxuICAgICAgICAgICAgICAgIGhpZGRlblN0cmluZ0FjdHVhbExlbmd0aDogbnVtYmVyO1xuXG4gICAgICAgICAgICBiZWZvcmUoKCkgPT4ge1xuICAgICAgICAgICAgICAgIG9yaWdpbmFsU3RyaW5nQWN0dWFsTGVuZ3RoID0gb3JpZ2luYWxTdHJpbmcubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGhpZGRlblN0cmluZ0FjdHVhbExlbmd0aCA9IGhpZGRlblN0cmluZy5sZW5ndGg7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaXQoJ3Nob3VsZCBjcmVhdGUgaGlkZGVuIHN0cmluZyB3aXRoIGxlbmd0aCBlcXVhbCBvciBiaWdnZXIgdGhhbiBnaXZlbiBsZW5ndGgnLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgYXNzZXJ0LmlzVHJ1ZShoaWRkZW5TdHJpbmdBY3R1YWxMZW5ndGggPiBvcmlnaW5hbFN0cmluZ0FjdHVhbExlbmd0aCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgZGVzY3JpYmUoJ2hpZGRlbiBzdHJpbmcgY29udGVudCcsICgpID0+IHtcbiAgICAgICAgICAgIGxldCBoaWRkZW5TdHJpbmdXaXRob3V0RGlmZjogc3RyaW5nO1xuXG4gICAgICAgICAgICBiZWZvcmUoKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlZ0V4cDogUmVnRXhwID0gbmV3IFJlZ0V4cChgWyR7ZGlmZlN0cmluZ31dYCwgJ2cnKTtcblxuICAgICAgICAgICAgICAgIGhpZGRlblN0cmluZ1dpdGhvdXREaWZmID0gaGlkZGVuU3RyaW5nLnJlcGxhY2UocmVnRXhwLCAnJyk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaXQoJ3Nob3VsZCByZXR1cm4gYSBoaWRkZW4gc3RyaW5nIHdpdGggdGhlIG9yaWdpbmFsIHN0cmluZyB3aXRoaW4nLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKGhpZGRlblN0cmluZ1dpdGhvdXREaWZmLCBvcmlnaW5hbFN0cmluZyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBkZXNjcmliZSgncmM0IChzdHJpbmc6IHN0cmluZywga2V5OiBzdHJpbmcpOiBzdHJpbmcnLCAoKSA9PiB7XG4gICAgICAgIGNvbnN0IHN0cmluZzogc3RyaW5nID0gJ3Rlc3QnO1xuICAgICAgICBjb25zdCBrZXk6IHN0cmluZyA9ICdrZXknO1xuXG4gICAgICAgIGxldCBlbmNvZGVkU3RyaW5nOiBzdHJpbmcsXG4gICAgICAgICAgICBkZWNvZGVkU3RyaW5nOiBzdHJpbmc7XG5cbiAgICAgICAgYmVmb3JlKCgpID0+IHtcbiAgICAgICAgICAgIGVuY29kZWRTdHJpbmcgPSBjcnlwdFV0aWxzLnJjNChzdHJpbmcsIGtleSk7XG4gICAgICAgICAgICBkZWNvZGVkU3RyaW5nID0gY3J5cHRVdGlscy5yYzQoZW5jb2RlZFN0cmluZywga2V5KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaXQoJ3Nob3VsZCBlbmNvZGUgc3RyaW5nIHVzaW5nIHRoZSByYzQgYWxnb3JpdGhtJywgKCkgPT4ge1xuICAgICAgICAgICAgYXNzZXJ0Lm5vdEVxdWFsKGVuY29kZWRTdHJpbmcsIHN0cmluZyk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGl0KCdzaG91bGQgZW5jb2RlIGFuZCBzdWNjZXNzZnVsbHkgZGVjb2RlIHN0cmluZyB1c2luZyB0aGUgcmM0IGFsZ29yaXRobScsICgpID0+IHtcbiAgICAgICAgICAgIGFzc2VydC5lcXVhbChkZWNvZGVkU3RyaW5nLCBzdHJpbmcpO1xuICAgICAgICB9KTtcbiAgICB9KTtcbn0pO1xuIl19