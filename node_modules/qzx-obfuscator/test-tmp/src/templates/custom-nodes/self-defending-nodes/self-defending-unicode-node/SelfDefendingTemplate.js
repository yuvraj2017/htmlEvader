"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function SelfDefendingTemplate(escapeSequenceEncoder) {
    return "\n        var {selfDefendingFunctionName} = {singleNodeCallControllerFunctionName}(this, function () {\n            var func1 = function(){return 'dev';},\n                func2 = function () {\n                    return 'window';\n                };\n                \n            var test1 = function () {\n                var regExp = new RegExp('" + escapeSequenceEncoder.encode("\\w+ *\\(\\) *{\\w+ *['|\"].+['|\"];? *}", true) + "');\n                \n                return !regExp.test(func1.toString());\n            };\n            \n            var test2 = function () {\n                var regExp = new RegExp('" + escapeSequenceEncoder.encode("(\\\\[x|u](\\w){2,4})+", true) + "');\n                \n                return regExp.test(func2.toString());\n            };\n            \n            var recursiveFunc1 = function (string) {\n                var i = ~-1 >> 1 + 255 % 0;\n                                \n                if (string.indexOf('i' === i)) {\n                    recursiveFunc2(string)\n                }\n            };\n            \n            var recursiveFunc2 = function (string) {\n                var i = ~-4 >> 1 + 255 % 0;\n                \n                if (string.indexOf((true+\"\")[3]) !== i) {\n                    recursiveFunc1(string)\n                }\n            };\n            \n            if (!test1()) {\n                if (!test2()) {\n                    recursiveFunc1('ind\u0435xOf');\n                } else {\n                    recursiveFunc1('indexOf');\n                }\n            } else {\n                recursiveFunc1('ind\u0435xOf');\n            }\n        })\n        \n        {selfDefendingFunctionName}();\n    ";
}
exports.SelfDefendingTemplate = SelfDefendingTemplate;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiU2VsZkRlZmVuZGluZ1RlbXBsYXRlLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vc3JjL3RlbXBsYXRlcy9jdXN0b20tbm9kZXMvc2VsZi1kZWZlbmRpbmctbm9kZXMvc2VsZi1kZWZlbmRpbmctdW5pY29kZS1ub2RlL1NlbGZEZWZlbmRpbmdUZW1wbGF0ZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7QUFTQSwrQkFBdUMsQUFBNkM7QUFDaEYsQUFBTSxBQUFDLCtXQVNTLEFBQXFCLHNCQUFDLEFBQU0sQUFBQyxBQUF3QyxtREFBRSxBQUFJLEFBQy9FLDBNQU9JLEFBQXFCLHNCQUFDLEFBQU0sQUFBQyxBQUF3QixpQ0FBRSxBQUFJLEFBQy9ELEFBaUNYLEFBQUMsQUFDTjtBQUFDO0FBckRELGdDQXFEQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IElFc2NhcGVTZXF1ZW5jZUVuY29kZXIgfSBmcm9tICcuLi8uLi8uLi8uLi9pbnRlcmZhY2VzL3V0aWxzL0lFc2NhcGVTZXF1ZW5jZUVuY29kZXInO1xuXG4vKipcbiAqIFNlbGZEZWZlbmRpbmdUZW1wbGF0ZS4gRW50ZXJzIGNvZGUgaW4gaW5maW5pdHkgbG9vcC5cbiAqIE5vdGljZSwgdGhhdCBzZWNvbmQgYW5kIHRoaXJkIGNhbGwgdG8gcmVjdXJzaXZlRnVuYzEoJ2luZGV4T2YnKSBoYXMgY3lyaWxsaWMgYNC1YCBjaGFyYWN0ZXIgaW5zdGVhZCBsYXRpblxuICpcbiAqIEBwYXJhbSB7SUVzY2FwZVNlcXVlbmNlRW5jb2Rlcn0gZXNjYXBlU2VxdWVuY2VFbmNvZGVyXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5leHBvcnQgZnVuY3Rpb24gU2VsZkRlZmVuZGluZ1RlbXBsYXRlIChlc2NhcGVTZXF1ZW5jZUVuY29kZXI6IElFc2NhcGVTZXF1ZW5jZUVuY29kZXIpOiBzdHJpbmcge1xuICAgIHJldHVybiBgXG4gICAgICAgIHZhciB7c2VsZkRlZmVuZGluZ0Z1bmN0aW9uTmFtZX0gPSB7c2luZ2xlTm9kZUNhbGxDb250cm9sbGVyRnVuY3Rpb25OYW1lfSh0aGlzLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgZnVuYzEgPSBmdW5jdGlvbigpe3JldHVybiAnZGV2Jzt9LFxuICAgICAgICAgICAgICAgIGZ1bmMyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ3dpbmRvdyc7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgIHZhciB0ZXN0MSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVnRXhwID0gbmV3IFJlZ0V4cCgnJHtcbiAgICAgICAgICAgICAgICAgICAgZXNjYXBlU2VxdWVuY2VFbmNvZGVyLmVuY29kZShgXFxcXHcrICpcXFxcKFxcXFwpICp7XFxcXHcrICpbJ3xcIl0uK1snfFwiXTs/ICp9YCwgdHJ1ZSlcbiAgICAgICAgICAgICAgICB9Jyk7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgcmV0dXJuICFyZWdFeHAudGVzdChmdW5jMS50b1N0cmluZygpKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHZhciB0ZXN0MiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVnRXhwID0gbmV3IFJlZ0V4cCgnJHtcbiAgICAgICAgICAgICAgICAgICAgZXNjYXBlU2VxdWVuY2VFbmNvZGVyLmVuY29kZShgKFxcXFxcXFxcW3h8dV0oXFxcXHcpezIsNH0pK2AsIHRydWUpXG4gICAgICAgICAgICAgICAgfScpO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIHJldHVybiByZWdFeHAudGVzdChmdW5jMi50b1N0cmluZygpKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHZhciByZWN1cnNpdmVGdW5jMSA9IGZ1bmN0aW9uIChzdHJpbmcpIHtcbiAgICAgICAgICAgICAgICB2YXIgaSA9IH4tMSA+PiAxICsgMjU1ICUgMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgaWYgKHN0cmluZy5pbmRleE9mKCdpJyA9PT0gaSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVjdXJzaXZlRnVuYzIoc3RyaW5nKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHZhciByZWN1cnNpdmVGdW5jMiA9IGZ1bmN0aW9uIChzdHJpbmcpIHtcbiAgICAgICAgICAgICAgICB2YXIgaSA9IH4tNCA+PiAxICsgMjU1ICUgMDtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBpZiAoc3RyaW5nLmluZGV4T2YoKHRydWUrXCJcIilbM10pICE9PSBpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlY3Vyc2l2ZUZ1bmMxKHN0cmluZylcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBpZiAoIXRlc3QxKCkpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXRlc3QyKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVjdXJzaXZlRnVuYzEoJ2luZNC1eE9mJyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVjdXJzaXZlRnVuYzEoJ2luZGV4T2YnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlY3Vyc2l2ZUZ1bmMxKCdpbmTQtXhPZicpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgICBcbiAgICAgICAge3NlbGZEZWZlbmRpbmdGdW5jdGlvbk5hbWV9KCk7XG4gICAgYDtcbn1cbiJdfQ==