"use strict";

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var inversify_1 = require("inversify");
var ServiceIdentifiers_1 = require("../../container/ServiceIdentifiers");
var CustomNodeGroup_1 = require("../../enums/container/custom-nodes/CustomNodeGroup");
var MapStorage_1 = require("../MapStorage");
var CustomNodeGroupStorage = CustomNodeGroupStorage_1 = function (_MapStorage_1$MapStor) {
    _inherits(CustomNodeGroupStorage, _MapStorage_1$MapStor);

    function CustomNodeGroupStorage(customNodeGroupFactory, randomGenerator, options) {
        _classCallCheck(this, CustomNodeGroupStorage);

        var _this = _possibleConstructorReturn(this, (CustomNodeGroupStorage.__proto__ || Object.getPrototypeOf(CustomNodeGroupStorage)).call(this, randomGenerator));

        _this.customNodeGroupFactory = customNodeGroupFactory;
        _this.options = options;
        _this.initialize();
        return _this;
    }

    _createClass(CustomNodeGroupStorage, [{
        key: "initialize",
        value: function initialize() {
            var _this2 = this;

            this.storage = new Map();
            this.storageId = this.randomGenerator.getRandomString(6);
            CustomNodeGroupStorage_1.customNodeGroupsList.forEach(function (customNodeGroupName) {
                var customNodeGroup = _this2.customNodeGroupFactory(customNodeGroupName);
                if (!customNodeGroup) {
                    return;
                }
                _this2.storage.set(customNodeGroupName, customNodeGroup);
            });
        }
    }]);

    return CustomNodeGroupStorage;
}(MapStorage_1.MapStorage);
CustomNodeGroupStorage.customNodeGroupsList = [CustomNodeGroup_1.CustomNodeGroup.ConsoleOutputCustomNodeGroup, CustomNodeGroup_1.CustomNodeGroup.DebugProtectionCustomNodeGroup, CustomNodeGroup_1.CustomNodeGroup.DomainLockCustomNodeGroup, CustomNodeGroup_1.CustomNodeGroup.SelfDefendingCustomNodeGroup, CustomNodeGroup_1.CustomNodeGroup.StringArrayCustomNodeGroup];
CustomNodeGroupStorage = CustomNodeGroupStorage_1 = tslib_1.__decorate([inversify_1.injectable(), tslib_1.__param(0, inversify_1.inject(ServiceIdentifiers_1.ServiceIdentifiers.Factory__ICustomNodeGroup)), tslib_1.__param(1, inversify_1.inject(ServiceIdentifiers_1.ServiceIdentifiers.IRandomGenerator)), tslib_1.__param(2, inversify_1.inject(ServiceIdentifiers_1.ServiceIdentifiers.IOptions)), tslib_1.__metadata("design:paramtypes", [Function, Object, Object])], CustomNodeGroupStorage);
exports.CustomNodeGroupStorage = CustomNodeGroupStorage;
var CustomNodeGroupStorage_1;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQ3VzdG9tTm9kZUdyb3VwU3RvcmFnZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9zdG9yYWdlcy9jdXN0b20tbm9kZS1ncm91cC9DdXN0b21Ob2RlR3JvdXBTdG9yYWdlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUFBLDBCQUErQztBQUMvQyxtQ0FBd0U7QUFReEUsZ0NBQXFGO0FBRXJGLDJCQUEyQztBQUczQyxJQUFhLEFBQXNCO0FBQW5DLEFBQW9DOztBQTJCaEMsb0NBQzBELEFBQStDLHdCQUN4RCxBQUFpQyxpQkFDekMsQUFBaUI7QUFFdEQsQUFBSzs7b0pBQUMsQUFBZSxBQUFDLEFBQUM7O0FBRXZCLEFBQUksY0FBQyxBQUFzQix5QkFBRyxBQUFzQixBQUFDO0FBQ3JELEFBQUksY0FBQyxBQUFPLFVBQUcsQUFBTyxBQUFDO0FBRXZCLEFBQUksY0FBQyxBQUFVLEFBQUUsQUFBQyxBQUN0Qjs7QUFBQyxBQUVNLEFBQVU7Ozs7Ozs7QUFDYixBQUFJLGlCQUFDLEFBQU8sVUFBRyxJQUFJLEFBQUcsQUFBNkIsQUFBQztBQUNwRCxBQUFJLGlCQUFDLEFBQVMsWUFBRyxBQUFJLEtBQUMsQUFBZSxnQkFBQyxBQUFlLGdCQUFDLEFBQUMsQUFBQyxBQUFDO0FBRXpELEFBQXNCLHFDQUFDLEFBQW9CLHFCQUFDLEFBQU8sUUFBQyxVQUFDLEFBQW9DO0FBQ3JGLG9CQUFNLEFBQWUsa0JBQXFCLEFBQUksT0FBQyxBQUFzQix1QkFDakUsQUFBbUIsQUFDdEIsQUFBQztBQUVGLEFBQUUsQUFBQyxvQkFBQyxDQUFDLEFBQWUsQUFBQyxpQkFBQyxBQUFDO0FBQ25CLEFBQU0sQUFBQyxBQUNYO0FBQUM7QUFFRCxBQUFJLHVCQUFDLEFBQU8sUUFBQyxBQUFHLElBQUMsQUFBbUIscUJBQUUsQUFBZSxBQUFDLEFBQUMsQUFDM0Q7QUFBQyxBQUFDLEFBQUMsQUFDUDtBQUFDLEFBQ0o7Ozs7RUF4RDJDLGFBQTZCO0FBSTdDLHVCQUFvQix1QkFBc0IsQ0FDOUQsa0JBQWUsZ0JBQUMsQUFBNEIsOEJBQzVDLGtCQUFlLGdCQUFDLEFBQThCLGdDQUM5QyxrQkFBZSxnQkFBQyxBQUF5QiwyQkFDekMsa0JBQWUsZ0JBQUMsQUFBNEIsOEJBQzVDLGtCQUFlLGdCQUFDLEFBQTBCLEFBQzdDLEFBQUM7QUFWTyxBQUFzQix3RUFEbEMsWUFBVSxBQUFFLGNBNkJKLG1CQUFBLFlBQU0sT0FBQyxxQkFBa0IsbUJBQUMsQUFBeUIsQUFBQyw2QkFDcEQsbUJBQUEsWUFBTSxPQUFDLHFCQUFrQixtQkFBQyxBQUFnQixBQUFDLG9CQUMzQyxtQkFBQSxZQUFNLE9BQUMscUJBQWtCLG1CQUFDLEFBQVEsQUFBQyxrRkE5Qi9CLEFBQXNCLEFBd0RsQztBQXhEWSxpQ0FBc0IiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBpbmplY3RhYmxlLCBpbmplY3QgfSBmcm9tICdpbnZlcnNpZnknO1xuaW1wb3J0IHsgU2VydmljZUlkZW50aWZpZXJzIH0gZnJvbSAnLi4vLi4vY29udGFpbmVyL1NlcnZpY2VJZGVudGlmaWVycyc7XG5cbmltcG9ydCB7IFRDdXN0b21Ob2RlR3JvdXBGYWN0b3J5IH0gZnJvbSAnLi4vLi4vdHlwZXMvY29udGFpbmVyL2N1c3RvbS1ub2Rlcy9UQ3VzdG9tTm9kZUdyb3VwRmFjdG9yeSc7XG5cbmltcG9ydCB7IElDdXN0b21Ob2RlR3JvdXAgfSBmcm9tICcuLi8uLi9pbnRlcmZhY2VzL2N1c3RvbS1ub2Rlcy9JQ3VzdG9tTm9kZUdyb3VwJztcbmltcG9ydCB7IElPcHRpb25zIH0gZnJvbSAnLi4vLi4vaW50ZXJmYWNlcy9vcHRpb25zL0lPcHRpb25zJztcbmltcG9ydCB7IElSYW5kb21HZW5lcmF0b3IgfSBmcm9tICcuLi8uLi9pbnRlcmZhY2VzL3V0aWxzL0lSYW5kb21HZW5lcmF0b3InO1xuXG5pbXBvcnQgeyBDdXN0b21Ob2RlR3JvdXAgfSBmcm9tICcuLi8uLi9lbnVtcy9jb250YWluZXIvY3VzdG9tLW5vZGVzL0N1c3RvbU5vZGVHcm91cCc7XG5cbmltcG9ydCB7IE1hcFN0b3JhZ2UgfSBmcm9tICcuLi9NYXBTdG9yYWdlJztcblxuQGluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIEN1c3RvbU5vZGVHcm91cFN0b3JhZ2UgZXh0ZW5kcyBNYXBTdG9yYWdlIDxJQ3VzdG9tTm9kZUdyb3VwPiB7XG4gICAgLyoqXG4gICAgICogQHR5cGUge0N1c3RvbU5vZGVHcm91cFtdfVxuICAgICAqL1xuICAgIHByaXZhdGUgc3RhdGljIHJlYWRvbmx5IGN1c3RvbU5vZGVHcm91cHNMaXN0OiBDdXN0b21Ob2RlR3JvdXBbXSA9IFtcbiAgICAgICAgQ3VzdG9tTm9kZUdyb3VwLkNvbnNvbGVPdXRwdXRDdXN0b21Ob2RlR3JvdXAsXG4gICAgICAgIEN1c3RvbU5vZGVHcm91cC5EZWJ1Z1Byb3RlY3Rpb25DdXN0b21Ob2RlR3JvdXAsXG4gICAgICAgIEN1c3RvbU5vZGVHcm91cC5Eb21haW5Mb2NrQ3VzdG9tTm9kZUdyb3VwLFxuICAgICAgICBDdXN0b21Ob2RlR3JvdXAuU2VsZkRlZmVuZGluZ0N1c3RvbU5vZGVHcm91cCxcbiAgICAgICAgQ3VzdG9tTm9kZUdyb3VwLlN0cmluZ0FycmF5Q3VzdG9tTm9kZUdyb3VwXG4gICAgXTtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtUQ3VzdG9tTm9kZXNGYWN0b3JpZXNGYWN0b3J5fVxuICAgICAqL1xuICAgIHByaXZhdGUgcmVhZG9ubHkgY3VzdG9tTm9kZUdyb3VwRmFjdG9yeTogVEN1c3RvbU5vZGVHcm91cEZhY3Rvcnk7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7SU9wdGlvbnN9XG4gICAgICovXG4gICAgcHJpdmF0ZSByZWFkb25seSBvcHRpb25zOiBJT3B0aW9ucztcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7VEN1c3RvbU5vZGVHcm91cEZhY3Rvcnl9IGN1c3RvbU5vZGVHcm91cEZhY3RvcnlcbiAgICAgKiBAcGFyYW0ge0lSYW5kb21HZW5lcmF0b3J9IHJhbmRvbUdlbmVyYXRvclxuICAgICAqIEBwYXJhbSB7SU9wdGlvbnN9IG9wdGlvbnNcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvciAoXG4gICAgICAgIEBpbmplY3QoU2VydmljZUlkZW50aWZpZXJzLkZhY3RvcnlfX0lDdXN0b21Ob2RlR3JvdXApIGN1c3RvbU5vZGVHcm91cEZhY3Rvcnk6IFRDdXN0b21Ob2RlR3JvdXBGYWN0b3J5LFxuICAgICAgICBAaW5qZWN0KFNlcnZpY2VJZGVudGlmaWVycy5JUmFuZG9tR2VuZXJhdG9yKSByYW5kb21HZW5lcmF0b3I6IElSYW5kb21HZW5lcmF0b3IsXG4gICAgICAgIEBpbmplY3QoU2VydmljZUlkZW50aWZpZXJzLklPcHRpb25zKSBvcHRpb25zOiBJT3B0aW9uc1xuICAgICkge1xuICAgICAgICBzdXBlcihyYW5kb21HZW5lcmF0b3IpO1xuXG4gICAgICAgIHRoaXMuY3VzdG9tTm9kZUdyb3VwRmFjdG9yeSA9IGN1c3RvbU5vZGVHcm91cEZhY3Rvcnk7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG5cbiAgICAgICAgdGhpcy5pbml0aWFsaXplKCk7XG4gICAgfVxuXG4gICAgcHVibGljIGluaXRpYWxpemUgKCk6IHZvaWQge1xuICAgICAgICB0aGlzLnN0b3JhZ2UgPSBuZXcgTWFwIDxzdHJpbmcsIElDdXN0b21Ob2RlR3JvdXA+KCk7XG4gICAgICAgIHRoaXMuc3RvcmFnZUlkID0gdGhpcy5yYW5kb21HZW5lcmF0b3IuZ2V0UmFuZG9tU3RyaW5nKDYpO1xuXG4gICAgICAgIEN1c3RvbU5vZGVHcm91cFN0b3JhZ2UuY3VzdG9tTm9kZUdyb3Vwc0xpc3QuZm9yRWFjaCgoY3VzdG9tTm9kZUdyb3VwTmFtZTogQ3VzdG9tTm9kZUdyb3VwKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBjdXN0b21Ob2RlR3JvdXA6IElDdXN0b21Ob2RlR3JvdXAgPSB0aGlzLmN1c3RvbU5vZGVHcm91cEZhY3RvcnkoXG4gICAgICAgICAgICAgICAgY3VzdG9tTm9kZUdyb3VwTmFtZVxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgaWYgKCFjdXN0b21Ob2RlR3JvdXApIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuc3RvcmFnZS5zZXQoY3VzdG9tTm9kZUdyb3VwTmFtZSwgY3VzdG9tTm9kZUdyb3VwKTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuIl19