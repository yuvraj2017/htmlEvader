"use strict";

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var inversify_1 = require("inversify");
var ServiceIdentifiers_1 = require("../../container/ServiceIdentifiers");
var MapStorage_1 = require("../MapStorage");
var ControlFlowStorage = function (_MapStorage_1$MapStor) {
    _inherits(ControlFlowStorage, _MapStorage_1$MapStor);

    function ControlFlowStorage(randomGenerator) {
        _classCallCheck(this, ControlFlowStorage);

        var _this = _possibleConstructorReturn(this, (ControlFlowStorage.__proto__ || Object.getPrototypeOf(ControlFlowStorage)).call(this, randomGenerator));

        _this.initialize();
        return _this;
    }

    return ControlFlowStorage;
}(MapStorage_1.MapStorage);
ControlFlowStorage = tslib_1.__decorate([inversify_1.injectable(), tslib_1.__param(0, inversify_1.inject(ServiceIdentifiers_1.ServiceIdentifiers.IRandomGenerator)), tslib_1.__metadata("design:paramtypes", [Object])], ControlFlowStorage);
exports.ControlFlowStorage = ControlFlowStorage;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQ29udHJvbEZsb3dTdG9yYWdlLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vc3JjL3N0b3JhZ2VzL2NvbnRyb2wtZmxvdy9Db250cm9sRmxvd1N0b3JhZ2UudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFBLDBCQUErQztBQUMvQyxtQ0FBd0U7QUFLeEUsMkJBQTJDO0FBRzNDO0FBQUEsQUFBYSxBQUFrQixBQUFDOztBQUk1QixnQ0FDaUQsQUFBaUM7QUFFOUUsQUFBSzs7NElBQUMsQUFBZSxBQUFDLEFBQUM7O0FBRXZCLEFBQUksY0FBQyxBQUFVLEFBQUUsQUFBQyxBQUN0Qjs7QUFBQyxBQUNKOzs7RUFYdUMsYUFBd0I7QUFBbkQsQUFBa0IseUNBRDlCLFlBQVUsQUFBRSxjQU1KLG1CQUFBLFlBQU0sT0FBQyxxQkFBa0IsbUJBQUMsQUFBZ0IsQUFBQyx3RUFMdkMsQUFBa0IsQUFXOUI7QUFYWSw2QkFBa0IiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBpbmplY3RhYmxlLCBpbmplY3QgfSBmcm9tICdpbnZlcnNpZnknO1xuaW1wb3J0IHsgU2VydmljZUlkZW50aWZpZXJzIH0gZnJvbSAnLi4vLi4vY29udGFpbmVyL1NlcnZpY2VJZGVudGlmaWVycyc7XG5cbmltcG9ydCB7IElDdXN0b21Ob2RlIH0gZnJvbSAnLi4vLi4vaW50ZXJmYWNlcy9jdXN0b20tbm9kZXMvSUN1c3RvbU5vZGUnO1xuaW1wb3J0IHsgSVJhbmRvbUdlbmVyYXRvciB9IGZyb20gJy4uLy4uL2ludGVyZmFjZXMvdXRpbHMvSVJhbmRvbUdlbmVyYXRvcic7XG5cbmltcG9ydCB7IE1hcFN0b3JhZ2UgfSBmcm9tICcuLi9NYXBTdG9yYWdlJztcblxuQGluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIENvbnRyb2xGbG93U3RvcmFnZSBleHRlbmRzIE1hcFN0b3JhZ2UgPElDdXN0b21Ob2RlPiB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtJUmFuZG9tR2VuZXJhdG9yfSByYW5kb21HZW5lcmF0b3JcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvciAoXG4gICAgICAgIEBpbmplY3QoU2VydmljZUlkZW50aWZpZXJzLklSYW5kb21HZW5lcmF0b3IpIHJhbmRvbUdlbmVyYXRvcjogSVJhbmRvbUdlbmVyYXRvclxuICAgICkge1xuICAgICAgICBzdXBlcihyYW5kb21HZW5lcmF0b3IpO1xuXG4gICAgICAgIHRoaXMuaW5pdGlhbGl6ZSgpO1xuICAgIH1cbn1cbiJdfQ==