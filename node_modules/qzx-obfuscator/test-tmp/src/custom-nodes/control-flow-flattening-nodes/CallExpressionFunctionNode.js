"use strict";

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var inversify_1 = require("inversify");
var ServiceIdentifiers_1 = require("../../container/ServiceIdentifiers");
var Initializable_1 = require("../../decorators/Initializable");
var AbstractCustomNode_1 = require("../AbstractCustomNode");
var Nodes_1 = require("../../node/Nodes");
var NodeUtils_1 = require("../../node/NodeUtils");
var CallExpressionFunctionNode = function (_AbstractCustomNode_) {
    _inherits(CallExpressionFunctionNode, _AbstractCustomNode_);

    function CallExpressionFunctionNode(randomGenerator, options) {
        _classCallCheck(this, CallExpressionFunctionNode);

        var _this = _possibleConstructorReturn(this, (CallExpressionFunctionNode.__proto__ || Object.getPrototypeOf(CallExpressionFunctionNode)).call(this, options));

        _this.randomGenerator = randomGenerator;
        return _this;
    }

    _createClass(CallExpressionFunctionNode, [{
        key: "initialize",
        value: function initialize(expressionArguments) {
            this.expressionArguments = expressionArguments;
        }
    }, {
        key: "getNodeStructure",
        value: function getNodeStructure() {
            var calleeIdentifier = Nodes_1.Nodes.getIdentifierNode('callee');
            var params = [];
            var argumentsLength = this.expressionArguments.length;
            for (var i = 0; i < argumentsLength; i++) {
                params.push(Nodes_1.Nodes.getIdentifierNode("param" + (i + 1)));
            }
            var structure = Nodes_1.Nodes.getFunctionDeclarationNode(this.randomGenerator.getRandomString(3), [calleeIdentifier].concat(params), Nodes_1.Nodes.getBlockStatementNode([Nodes_1.Nodes.getReturnStatementNode(Nodes_1.Nodes.getCallExpressionNode(calleeIdentifier, params))]));
            NodeUtils_1.NodeUtils.parentize(structure);
            return [structure];
        }
    }]);

    return CallExpressionFunctionNode;
}(AbstractCustomNode_1.AbstractCustomNode);
tslib_1.__decorate([Initializable_1.initializable(), tslib_1.__metadata("design:type", Array)], CallExpressionFunctionNode.prototype, "expressionArguments", void 0);
CallExpressionFunctionNode = tslib_1.__decorate([inversify_1.injectable(), tslib_1.__param(0, inversify_1.inject(ServiceIdentifiers_1.ServiceIdentifiers.IRandomGenerator)), tslib_1.__param(1, inversify_1.inject(ServiceIdentifiers_1.ServiceIdentifiers.IOptions)), tslib_1.__metadata("design:paramtypes", [Object, Object])], CallExpressionFunctionNode);
exports.CallExpressionFunctionNode = CallExpressionFunctionNode;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQ2FsbEV4cHJlc3Npb25GdW5jdGlvbk5vZGUuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi9zcmMvY3VzdG9tLW5vZGVzL2NvbnRyb2wtZmxvdy1mbGF0dGVuaW5nLW5vZGVzL0NhbGxFeHByZXNzaW9uRnVuY3Rpb25Ob2RlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUFBLDBCQUErQztBQUMvQyxtQ0FBd0U7QUFTeEUsOEJBQStEO0FBRS9ELG1DQUEyRDtBQUMzRCxzQkFBeUM7QUFDekMsMEJBQWlEO0FBR2pEO0FBQUEsQUFBYSxBQUEwQixBQUFDOztBQWdCcEMsd0NBQ2lELEFBQWlDLGlCQUN6QyxBQUFpQjtBQUV0RCxBQUFLOzs0SkFBQyxBQUFPLEFBQUMsQUFBQzs7QUFFZixBQUFJLGNBQUMsQUFBZSxrQkFBRyxBQUFlLEFBQUMsQUFDM0M7O0FBQUMsQUFLTSxBQUFVOzs7O21DQUFFLEFBQWlFO0FBQ2hGLEFBQUksaUJBQUMsQUFBbUIsc0JBQUcsQUFBbUIsQUFBQyxBQUNuRDtBQUFDLEFBS1MsQUFBZ0I7Ozs7QUFDdEIsZ0JBQU0sQUFBZ0IsbUJBQXNCLFFBQUssTUFBQyxBQUFpQixrQkFBQyxBQUFRLEFBQUMsQUFBQztBQUM5RSxnQkFBTSxBQUFNLFNBQXdCLEFBQUUsQUFBQztBQUN2QyxnQkFBTSxBQUFlLGtCQUFXLEFBQUksS0FBQyxBQUFtQixvQkFBQyxBQUFNLEFBQUM7QUFFaEUsQUFBRyxBQUFDLGlCQUFDLElBQUksQUFBQyxJQUFXLEFBQUMsR0FBRSxBQUFDLElBQUcsQUFBZSxpQkFBRSxBQUFDLEFBQUUsS0FBRSxBQUFDO0FBQy9DLEFBQU0sdUJBQUMsQUFBSSxLQUFDLFFBQUssTUFBQyxBQUFpQixBQUFDLDZCQUFRLEFBQUMsSUFBRyxBQUFDLEFBQUUsQUFBQyxBQUFDLEFBQUMsQUFDMUQ7QUFBQztBQUVELGdCQUFNLEFBQVMsWUFBZSxRQUFLLE1BQUMsQUFBMEIsMkJBQzFELEFBQUksS0FBQyxBQUFlLGdCQUFDLEFBQWUsZ0JBQUMsQUFBQyxBQUFDLEFBQ3ZDLEtBQ0ksQUFBZ0IsQUFDaEIseUJBQUcsQUFBTSxBQUNaLFNBQ0QsUUFBSyxNQUFDLEFBQXFCLHNCQUFDLENBQ3hCLFFBQUssTUFBQyxBQUFzQix1QkFDeEIsUUFBSyxNQUFDLEFBQXFCLHNCQUN2QixBQUFnQixrQkFDaEIsQUFBTSxBQUNULEFBQ0osQUFDSixBQUFDLEFBQ0wsQUFBQztBQUVGLHdCQUFTLFVBQUMsQUFBUyxVQUFDLEFBQVMsQUFBQyxBQUFDO0FBRS9CLEFBQU0sbUJBQUMsQ0FBQyxBQUFTLEFBQUMsQUFBQyxBQUN2QjtBQUFDLEFBQ0o7Ozs7RUFoRStDLHFCQUFrQjtBQUs5RCxvQkFEQyxnQkFBYSxBQUFFLDhIQUMwRDtBQUxqRSxBQUEwQixpREFEdEMsWUFBVSxBQUFFLGNBa0JKLG1CQUFBLFlBQU0sT0FBQyxxQkFBa0IsbUJBQUMsQUFBZ0IsQUFBQyxvQkFDM0MsbUJBQUEsWUFBTSxPQUFDLHFCQUFrQixtQkFBQyxBQUFRLEFBQUMsd0VBbEIvQixBQUEwQixBQWdFdEM7QUFoRVkscUNBQTBCIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgaW5qZWN0YWJsZSwgaW5qZWN0IH0gZnJvbSAnaW52ZXJzaWZ5JztcbmltcG9ydCB7IFNlcnZpY2VJZGVudGlmaWVycyB9IGZyb20gJy4uLy4uL2NvbnRhaW5lci9TZXJ2aWNlSWRlbnRpZmllcnMnO1xuXG5pbXBvcnQgKiBhcyBFU1RyZWUgZnJvbSAnZXN0cmVlJztcblxuaW1wb3J0IHsgVFN0YXRlbWVudCB9IGZyb20gJy4uLy4uL3R5cGVzL25vZGUvVFN0YXRlbWVudCc7XG5cbmltcG9ydCB7IElPcHRpb25zIH0gZnJvbSAnLi4vLi4vaW50ZXJmYWNlcy9vcHRpb25zL0lPcHRpb25zJztcbmltcG9ydCB7IElSYW5kb21HZW5lcmF0b3IgfSBmcm9tICcuLi8uLi9pbnRlcmZhY2VzL3V0aWxzL0lSYW5kb21HZW5lcmF0b3InO1xuXG5pbXBvcnQgeyBpbml0aWFsaXphYmxlIH0gZnJvbSAnLi4vLi4vZGVjb3JhdG9ycy9Jbml0aWFsaXphYmxlJztcblxuaW1wb3J0IHsgQWJzdHJhY3RDdXN0b21Ob2RlIH0gZnJvbSAnLi4vQWJzdHJhY3RDdXN0b21Ob2RlJztcbmltcG9ydCB7IE5vZGVzIH0gZnJvbSAnLi4vLi4vbm9kZS9Ob2Rlcyc7XG5pbXBvcnQgeyBOb2RlVXRpbHMgfSBmcm9tICcuLi8uLi9ub2RlL05vZGVVdGlscyc7XG5cbkBpbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBDYWxsRXhwcmVzc2lvbkZ1bmN0aW9uTm9kZSBleHRlbmRzIEFic3RyYWN0Q3VzdG9tTm9kZSB7XG4gICAgLyoqXG4gICAgICogQHR5cGUgeyhFU1RyZWUuRXhwcmVzc2lvbiB8IEVTVHJlZS5TcHJlYWRFbGVtZW50KVtdfVxuICAgICAqL1xuICAgIEBpbml0aWFsaXphYmxlKClcbiAgICBwcml2YXRlIGV4cHJlc3Npb25Bcmd1bWVudHM6IChFU1RyZWUuRXhwcmVzc2lvbiB8IEVTVHJlZS5TcHJlYWRFbGVtZW50KVtdO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge0lSYW5kb21HZW5lcmF0b3J9XG4gICAgICovXG4gICAgcHJpdmF0ZSByZWFkb25seSByYW5kb21HZW5lcmF0b3I6IElSYW5kb21HZW5lcmF0b3I7XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0lSYW5kb21HZW5lcmF0b3J9IHJhbmRvbUdlbmVyYXRvclxuICAgICAqIEBwYXJhbSB7SU9wdGlvbnN9IG9wdGlvbnNcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvciAoXG4gICAgICAgIEBpbmplY3QoU2VydmljZUlkZW50aWZpZXJzLklSYW5kb21HZW5lcmF0b3IpIHJhbmRvbUdlbmVyYXRvcjogSVJhbmRvbUdlbmVyYXRvcixcbiAgICAgICAgQGluamVjdChTZXJ2aWNlSWRlbnRpZmllcnMuSU9wdGlvbnMpIG9wdGlvbnM6IElPcHRpb25zXG4gICAgKSB7XG4gICAgICAgIHN1cGVyKG9wdGlvbnMpO1xuXG4gICAgICAgIHRoaXMucmFuZG9tR2VuZXJhdG9yID0gcmFuZG9tR2VuZXJhdG9yO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7KEV4cHJlc3Npb24gfCBTcHJlYWRFbGVtZW50KVtdfSBleHByZXNzaW9uQXJndW1lbnRzXG4gICAgICovXG4gICAgcHVibGljIGluaXRpYWxpemUgKGV4cHJlc3Npb25Bcmd1bWVudHM6IChFU1RyZWUuRXhwcmVzc2lvbiB8IEVTVHJlZS5TcHJlYWRFbGVtZW50KVtdKTogdm9pZCB7XG4gICAgICAgIHRoaXMuZXhwcmVzc2lvbkFyZ3VtZW50cyA9IGV4cHJlc3Npb25Bcmd1bWVudHM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMge1RTdGF0ZW1lbnRbXX1cbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgZ2V0Tm9kZVN0cnVjdHVyZSAoKTogVFN0YXRlbWVudFtdIHtcbiAgICAgICAgY29uc3QgY2FsbGVlSWRlbnRpZmllcjogRVNUcmVlLklkZW50aWZpZXIgPSBOb2Rlcy5nZXRJZGVudGlmaWVyTm9kZSgnY2FsbGVlJyk7XG4gICAgICAgIGNvbnN0IHBhcmFtczogRVNUcmVlLklkZW50aWZpZXJbXSA9IFtdO1xuICAgICAgICBjb25zdCBhcmd1bWVudHNMZW5ndGg6IG51bWJlciA9IHRoaXMuZXhwcmVzc2lvbkFyZ3VtZW50cy5sZW5ndGg7XG5cbiAgICAgICAgZm9yIChsZXQgaTogbnVtYmVyID0gMDsgaSA8IGFyZ3VtZW50c0xlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBwYXJhbXMucHVzaChOb2Rlcy5nZXRJZGVudGlmaWVyTm9kZShgcGFyYW0ke2kgKyAxfWApKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHN0cnVjdHVyZTogVFN0YXRlbWVudCA9IE5vZGVzLmdldEZ1bmN0aW9uRGVjbGFyYXRpb25Ob2RlKFxuICAgICAgICAgICAgdGhpcy5yYW5kb21HZW5lcmF0b3IuZ2V0UmFuZG9tU3RyaW5nKDMpLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIGNhbGxlZUlkZW50aWZpZXIsXG4gICAgICAgICAgICAgICAgLi4ucGFyYW1zXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgTm9kZXMuZ2V0QmxvY2tTdGF0ZW1lbnROb2RlKFtcbiAgICAgICAgICAgICAgICBOb2Rlcy5nZXRSZXR1cm5TdGF0ZW1lbnROb2RlKFxuICAgICAgICAgICAgICAgICAgICBOb2Rlcy5nZXRDYWxsRXhwcmVzc2lvbk5vZGUoXG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsZWVJZGVudGlmaWVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zXG4gICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICBdKVxuICAgICAgICApO1xuXG4gICAgICAgIE5vZGVVdGlscy5wYXJlbnRpemUoc3RydWN0dXJlKTtcblxuICAgICAgICByZXR1cm4gW3N0cnVjdHVyZV07XG4gICAgfVxufVxuIl19