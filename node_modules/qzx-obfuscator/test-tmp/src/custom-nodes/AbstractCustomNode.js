"use strict";

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var inversify_1 = require("inversify");
var ServiceIdentifiers_1 = require("../container/ServiceIdentifiers");
var NodeUtils_1 = require("../node/NodeUtils");
var AbstractCustomNode = function () {
    function AbstractCustomNode(options) {
        _classCallCheck(this, AbstractCustomNode);

        this.options = options;
    }

    _createClass(AbstractCustomNode, [{
        key: "getCode",
        value: function getCode() {
            if (!this.cachedCode) {
                this.cachedCode = NodeUtils_1.NodeUtils.convertStructureToCode(this.getNode());
            }
            return this.cachedCode;
        }
    }, {
        key: "getNode",
        value: function getNode() {
            if (!this.cachedNode) {
                this.cachedNode = this.getNodeStructure();
            }
            return this.cachedNode;
        }
    }]);

    return AbstractCustomNode;
}();
AbstractCustomNode = tslib_1.__decorate([inversify_1.injectable(), tslib_1.__param(0, inversify_1.inject(ServiceIdentifiers_1.ServiceIdentifiers.IOptions)), tslib_1.__metadata("design:paramtypes", [Object])], AbstractCustomNode);
exports.AbstractCustomNode = AbstractCustomNode;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQWJzdHJhY3RDdXN0b21Ob2RlLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vc3JjL2N1c3RvbS1ub2Rlcy9BYnN0cmFjdEN1c3RvbU5vZGUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQSwwQkFBK0M7QUFDL0MsbUNBQXFFO0FBTXJFLDBCQUE4QztBQUc5QztBQW1CSSxnQ0FDeUMsQUFBaUI7OztBQUV0RCxBQUFJLGFBQUMsQUFBTyxVQUFHLEFBQU8sQUFBQyxBQUMzQjtBQUFDLEFBVU0sQUFBTzs7QUFqQ2xCLEFBQXNCLEFBQWtCOzs7QUFrQ2hDLEFBQUUsQUFBQyxnQkFBQyxDQUFDLEFBQUksS0FBQyxBQUFVLEFBQUMsWUFBQyxBQUFDO0FBQ25CLEFBQUkscUJBQUMsQUFBVSxhQUFHLFlBQVMsVUFBQyxBQUFzQix1QkFBQyxBQUFJLEtBQUMsQUFBTyxBQUFFLEFBQUMsQUFBQyxBQUN2RTtBQUFDO0FBRUQsQUFBTSxtQkFBQyxBQUFJLEtBQUMsQUFBVSxBQUFDLEFBQzNCO0FBQUMsQUFLTSxBQUFPOzs7O0FBQ1YsQUFBRSxBQUFDLGdCQUFDLENBQUMsQUFBSSxLQUFDLEFBQVUsQUFBQyxZQUFDLEFBQUM7QUFDbkIsQUFBSSxxQkFBQyxBQUFVLGFBQUcsQUFBSSxLQUFDLEFBQWdCLEFBQUUsQUFBQyxBQUM5QztBQUFDO0FBRUQsQUFBTSxtQkFBQyxBQUFJLEtBQUMsQUFBVSxBQUFDLEFBQzNCO0FBQUMsQUFNSjs7Ozs7QUF4RHFCLEFBQWtCLHlDQUR2QyxZQUFVLEFBQUUsY0FxQkosbUJBQUEsWUFBTSxPQUFDLHFCQUFrQixtQkFBQyxBQUFRLEFBQUMsZ0VBcEJ0QixBQUFrQixBQXdEdkM7QUF4RHFCLDZCQUFrQiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGluamVjdGFibGUsIGluamVjdCB9IGZyb20gJ2ludmVyc2lmeSc7XG5pbXBvcnQgeyBTZXJ2aWNlSWRlbnRpZmllcnMgfSBmcm9tICcuLi9jb250YWluZXIvU2VydmljZUlkZW50aWZpZXJzJztcblxuaW1wb3J0IHsgSUN1c3RvbU5vZGUgfSBmcm9tICcuLi9pbnRlcmZhY2VzL2N1c3RvbS1ub2Rlcy9JQ3VzdG9tTm9kZSc7XG5pbXBvcnQgeyBJT3B0aW9ucyB9IGZyb20gJy4uL2ludGVyZmFjZXMvb3B0aW9ucy9JT3B0aW9ucyc7XG5pbXBvcnQgeyBUU3RhdGVtZW50IH0gZnJvbSAnLi4vdHlwZXMvbm9kZS9UU3RhdGVtZW50JztcblxuaW1wb3J0IHsgTm9kZVV0aWxzIH0gZnJvbSAnLi4vbm9kZS9Ob2RlVXRpbHMnO1xuXG5AaW5qZWN0YWJsZSgpXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgQWJzdHJhY3RDdXN0b21Ob2RlIGltcGxlbWVudHMgSUN1c3RvbU5vZGUge1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgcHJvdGVjdGVkIGNhY2hlZENvZGU6IHN0cmluZztcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtUU3RhdGVtZW50W119XG4gICAgICovXG4gICAgcHJvdGVjdGVkIGNhY2hlZE5vZGU6IFRTdGF0ZW1lbnRbXTtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtJT3B0aW9uc31cbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgcmVhZG9ubHkgb3B0aW9uczogSU9wdGlvbnM7XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0lPcHRpb25zfSBvcHRpb25zXG4gICAgICovXG4gICAgY29uc3RydWN0b3IgKFxuICAgICAgICBAaW5qZWN0KFNlcnZpY2VJZGVudGlmaWVycy5JT3B0aW9ucykgb3B0aW9uczogSU9wdGlvbnNcbiAgICApIHtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge2FueVtdfSBhcmdzXG4gICAgICovXG4gICAgcHVibGljIGFic3RyYWN0IGluaXRpYWxpemUgKC4uLmFyZ3M6IGFueVtdKTogdm9pZDtcblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICovXG4gICAgcHVibGljIGdldENvZGUgKCk6IHN0cmluZyB7XG4gICAgICAgIGlmICghdGhpcy5jYWNoZWRDb2RlKSB7XG4gICAgICAgICAgICB0aGlzLmNhY2hlZENvZGUgPSBOb2RlVXRpbHMuY29udmVydFN0cnVjdHVyZVRvQ29kZSh0aGlzLmdldE5vZGUoKSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5jYWNoZWRDb2RlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtUU3RhdGVtZW50W119XG4gICAgICovXG4gICAgcHVibGljIGdldE5vZGUgKCk6IFRTdGF0ZW1lbnRbXSB7XG4gICAgICAgIGlmICghdGhpcy5jYWNoZWROb2RlKSB7XG4gICAgICAgICAgICB0aGlzLmNhY2hlZE5vZGUgPSB0aGlzLmdldE5vZGVTdHJ1Y3R1cmUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLmNhY2hlZE5vZGU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMge1RTdGF0ZW1lbnRbXX1cbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgYWJzdHJhY3QgZ2V0Tm9kZVN0cnVjdHVyZSAoKTogVFN0YXRlbWVudFtdO1xufVxuIl19