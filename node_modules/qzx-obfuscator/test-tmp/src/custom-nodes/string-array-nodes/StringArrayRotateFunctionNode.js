"use strict";

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var inversify_1 = require("inversify");
var ServiceIdentifiers_1 = require("../../container/ServiceIdentifiers");
var format = require("string-template");
var Initializable_1 = require("../../decorators/Initializable");
var NoCustomNodes_1 = require("../../options/presets/NoCustomNodes");
var SelfDefendingTemplate_1 = require("../../templates/custom-nodes/string-array-nodes/string-array-rotate-function-node/SelfDefendingTemplate");
var StringArrayRotateFunctionTemplate_1 = require("../../templates/custom-nodes/string-array-nodes/string-array-rotate-function-node/StringArrayRotateFunctionTemplate");
var AbstractCustomNode_1 = require("../AbstractCustomNode");
var JavaScriptObfuscator_1 = require("../../JavaScriptObfuscator");
var NodeUtils_1 = require("../../node/NodeUtils");
var Utils_1 = require("../../utils/Utils");
var StringArrayRotateFunctionNode = function (_AbstractCustomNode_) {
    _inherits(StringArrayRotateFunctionNode, _AbstractCustomNode_);

    function StringArrayRotateFunctionNode(randomGenerator, escapeSequenceEncoder, options) {
        _classCallCheck(this, StringArrayRotateFunctionNode);

        var _this = _possibleConstructorReturn(this, (StringArrayRotateFunctionNode.__proto__ || Object.getPrototypeOf(StringArrayRotateFunctionNode)).call(this, options));

        _this.randomGenerator = randomGenerator;
        _this.escapeSequenceEncoder = escapeSequenceEncoder;
        return _this;
    }

    _createClass(StringArrayRotateFunctionNode, [{
        key: "initialize",
        value: function initialize(stringArrayStorage, stringArrayName, stringArrayRotateValue) {
            this.stringArrayStorage = stringArrayStorage;
            this.stringArrayName = stringArrayName;
            this.stringArrayRotateValue = stringArrayRotateValue;
        }
    }, {
        key: "getNodeStructure",
        value: function getNodeStructure() {
            return NodeUtils_1.NodeUtils.convertCodeToStructure(this.getTemplate());
        }
    }, {
        key: "getTemplate",
        value: function getTemplate() {
            var timesName = this.randomGenerator.getRandomVariableName(6);
            var whileFunctionName = this.randomGenerator.getRandomVariableName(6);
            var code = '';
            if (this.options.selfDefending) {
                code = format(SelfDefendingTemplate_1.SelfDefendingTemplate(this.escapeSequenceEncoder), {
                    timesName: timesName,
                    whileFunctionName: whileFunctionName
                });
            } else {
                code = whileFunctionName + "(++" + timesName + ")";
            }
            return JavaScriptObfuscator_1.JavaScriptObfuscator.obfuscate(format(StringArrayRotateFunctionTemplate_1.StringArrayRotateFunctionTemplate(), {
                code: code,
                timesName: timesName,
                stringArrayName: this.stringArrayName,
                stringArrayRotateValue: Utils_1.Utils.decToHex(this.stringArrayRotateValue),
                whileFunctionName: whileFunctionName
            }), Object.assign({}, NoCustomNodes_1.NO_CUSTOM_NODES_PRESET, { seed: this.options.seed })).getObfuscatedCode();
        }
    }]);

    return StringArrayRotateFunctionNode;
}(AbstractCustomNode_1.AbstractCustomNode);
tslib_1.__decorate([Initializable_1.initializable(), tslib_1.__metadata("design:type", Object)], StringArrayRotateFunctionNode.prototype, "stringArrayStorage", void 0);
tslib_1.__decorate([Initializable_1.initializable(), tslib_1.__metadata("design:type", String)], StringArrayRotateFunctionNode.prototype, "stringArrayName", void 0);
tslib_1.__decorate([Initializable_1.initializable(), tslib_1.__metadata("design:type", Number)], StringArrayRotateFunctionNode.prototype, "stringArrayRotateValue", void 0);
StringArrayRotateFunctionNode = tslib_1.__decorate([inversify_1.injectable(), tslib_1.__param(0, inversify_1.inject(ServiceIdentifiers_1.ServiceIdentifiers.IRandomGenerator)), tslib_1.__param(1, inversify_1.inject(ServiceIdentifiers_1.ServiceIdentifiers.IEscapeSequenceEncoder)), tslib_1.__param(2, inversify_1.inject(ServiceIdentifiers_1.ServiceIdentifiers.IOptions)), tslib_1.__metadata("design:paramtypes", [Object, Object, Object])], StringArrayRotateFunctionNode);
exports.StringArrayRotateFunctionNode = StringArrayRotateFunctionNode;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiU3RyaW5nQXJyYXlSb3RhdGVGdW5jdGlvbk5vZGUuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi9zcmMvY3VzdG9tLW5vZGVzL3N0cmluZy1hcnJheS1ub2Rlcy9TdHJpbmdBcnJheVJvdGF0ZUZ1bmN0aW9uTm9kZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFBQSwwQkFBK0M7QUFDL0MsbUNBQXdFO0FBRXhFLHFCQUEwQztBQVMxQyw4QkFBK0Q7QUFFL0QsOEJBQTZFO0FBRTdFLHNDQUFnSjtBQUNoSixrREFBd0s7QUFFeEssbUNBQTJEO0FBQzNELHFDQUFrRTtBQUNsRSwwQkFBaUQ7QUFDakQsc0JBQTBDO0FBRzFDO0FBQUEsQUFBYSxBQUE2QixBQUFDOztBQWtDdkMsMkNBQ2lELEFBQWlDLGlCQUMzQixBQUE2Qyx1QkFDM0QsQUFBaUI7QUFFdEQsQUFBSzs7a0tBQUMsQUFBTyxBQUFDLEFBQUM7O0FBRWYsQUFBSSxjQUFDLEFBQWUsa0JBQUcsQUFBZSxBQUFDO0FBQ3ZDLEFBQUksY0FBQyxBQUFxQix3QkFBRyxBQUFxQixBQUFDLEFBQ3ZEOztBQUFDLEFBT00sQUFBVTs7OzttQ0FDYixBQUFxQyxvQkFDckMsQUFBdUIsaUJBQ3ZCLEFBQThCO0FBRTlCLEFBQUksaUJBQUMsQUFBa0IscUJBQUcsQUFBa0IsQUFBQztBQUM3QyxBQUFJLGlCQUFDLEFBQWUsa0JBQUcsQUFBZSxBQUFDO0FBQ3ZDLEFBQUksaUJBQUMsQUFBc0IseUJBQUcsQUFBc0IsQUFBQyxBQUN6RDtBQUFDLEFBS1MsQUFBZ0I7Ozs7QUFDdEIsQUFBTSxtQkFBQyxZQUFTLFVBQUMsQUFBc0IsdUJBQUMsQUFBSSxLQUFDLEFBQVcsQUFBRSxBQUFDLEFBQUMsQUFDaEU7QUFBQyxBQUtTLEFBQVc7Ozs7QUFDakIsZ0JBQU0sQUFBUyxZQUFXLEFBQUksS0FBQyxBQUFlLGdCQUFDLEFBQXFCLHNCQUFDLEFBQUMsQUFBQyxBQUFDO0FBQ3hFLGdCQUFNLEFBQWlCLG9CQUFXLEFBQUksS0FBQyxBQUFlLGdCQUFDLEFBQXFCLHNCQUFDLEFBQUMsQUFBQyxBQUFDO0FBRWhGLGdCQUFJLEFBQUksT0FBVyxBQUFFLEFBQUM7QUFFdEIsQUFBRSxBQUFDLGdCQUFDLEFBQUksS0FBQyxBQUFPLFFBQUMsQUFBYSxBQUFDLGVBQUMsQUFBQztBQUM3QixBQUFJLDhCQUFVLHdCQUFxQixzQkFBQyxBQUFJLEtBQUMsQUFBcUIsQUFBQztBQUMzRCxBQUFTO0FBQ1QsQUFBaUIsQUFDcEIsQUFBQyxBQUFDLEFBQ1A7QUFKcUUsaUJBQTFELEFBQU07QUFJaEIsQUFBQyxBQUFJLG1CQUFDLEFBQUM7QUFDSixBQUFJLEFBQUcsdUJBQUcsQUFBaUIsNEJBQU0sQUFBUyxBQUFHLEFBQUMsQUFDbEQ7QUFBQztBQUVELEFBQU0sMENBQXFCLHFCQUFDLEFBQVMsaUJBQzFCLG9DQUFpQyxBQUFFO0FBQ3RDLEFBQUk7QUFDSixBQUFTO0FBQ1QsQUFBZSxpQ0FBRSxBQUFJLEtBQUMsQUFBZTtBQUNyQyxBQUFzQix3Q0FBRSxRQUFLLE1BQUMsQUFBUSxTQUFDLEFBQUksS0FBQyxBQUFzQixBQUFDO0FBQ25FLEFBQWlCLEFBQ3BCLEFBQUM7QUFOMEMsYUFBNUMsQUFBTSxDQURILG9CQVNJLGdCQUFzQiwwQkFDekIsQUFBSSxNQUFFLEFBQUksS0FBQyxBQUFPLFFBQUMsQUFBSSxBQUU5QixTQUFDLEFBQWlCLEFBQUUsQUFBQyxBQUMxQjtBQUFDLEFBQ0o7Ozs7RUFuR2tELHFCQUFrQjtBQWVqRSxvQkFEQyxnQkFBYSxBQUFFLGlJQUM4QjtBQU05QyxvQkFEQyxnQkFBYSxBQUFFLDhIQUNnQjtBQU1oQyxvQkFEQyxnQkFBYSxBQUFFLHFJQUN1QjtBQTNCOUIsQUFBNkIsb0RBRHpDLFlBQVUsQUFBRSxjQW9DSixtQkFBQSxZQUFNLE9BQUMscUJBQWtCLG1CQUFDLEFBQWdCLEFBQUMsb0JBQzNDLG1CQUFBLFlBQU0sT0FBQyxxQkFBa0IsbUJBQUMsQUFBc0IsQUFBQywwQkFDakQsbUJBQUEsWUFBTSxPQUFDLHFCQUFrQixtQkFBQyxBQUFRLEFBQUMsZ0ZBckMvQixBQUE2QixBQW1HekM7QUFuR1ksd0NBQTZCIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgaW5qZWN0YWJsZSwgaW5qZWN0IH0gZnJvbSAnaW52ZXJzaWZ5JztcbmltcG9ydCB7IFNlcnZpY2VJZGVudGlmaWVycyB9IGZyb20gJy4uLy4uL2NvbnRhaW5lci9TZXJ2aWNlSWRlbnRpZmllcnMnO1xuXG5pbXBvcnQgKiBhcyBmb3JtYXQgZnJvbSAnc3RyaW5nLXRlbXBsYXRlJztcblxuaW1wb3J0IHsgVFN0YXRlbWVudCB9IGZyb20gJy4uLy4uL3R5cGVzL25vZGUvVFN0YXRlbWVudCc7XG5cbmltcG9ydCB7IElFc2NhcGVTZXF1ZW5jZUVuY29kZXIgfSBmcm9tICcuLi8uLi9pbnRlcmZhY2VzL3V0aWxzL0lFc2NhcGVTZXF1ZW5jZUVuY29kZXInO1xuaW1wb3J0IHsgSU9wdGlvbnMgfSBmcm9tICcuLi8uLi9pbnRlcmZhY2VzL29wdGlvbnMvSU9wdGlvbnMnO1xuaW1wb3J0IHsgSVJhbmRvbUdlbmVyYXRvciB9IGZyb20gJy4uLy4uL2ludGVyZmFjZXMvdXRpbHMvSVJhbmRvbUdlbmVyYXRvcic7XG5pbXBvcnQgeyBJU3RvcmFnZSB9IGZyb20gJy4uLy4uL2ludGVyZmFjZXMvc3RvcmFnZXMvSVN0b3JhZ2UnO1xuXG5pbXBvcnQgeyBpbml0aWFsaXphYmxlIH0gZnJvbSAnLi4vLi4vZGVjb3JhdG9ycy9Jbml0aWFsaXphYmxlJztcblxuaW1wb3J0IHsgTk9fQ1VTVE9NX05PREVTX1BSRVNFVCB9IGZyb20gJy4uLy4uL29wdGlvbnMvcHJlc2V0cy9Ob0N1c3RvbU5vZGVzJztcblxuaW1wb3J0IHsgU2VsZkRlZmVuZGluZ1RlbXBsYXRlIH0gZnJvbSAnLi4vLi4vdGVtcGxhdGVzL2N1c3RvbS1ub2Rlcy9zdHJpbmctYXJyYXktbm9kZXMvc3RyaW5nLWFycmF5LXJvdGF0ZS1mdW5jdGlvbi1ub2RlL1NlbGZEZWZlbmRpbmdUZW1wbGF0ZSc7XG5pbXBvcnQgeyBTdHJpbmdBcnJheVJvdGF0ZUZ1bmN0aW9uVGVtcGxhdGUgfSBmcm9tICcuLi8uLi90ZW1wbGF0ZXMvY3VzdG9tLW5vZGVzL3N0cmluZy1hcnJheS1ub2Rlcy9zdHJpbmctYXJyYXktcm90YXRlLWZ1bmN0aW9uLW5vZGUvU3RyaW5nQXJyYXlSb3RhdGVGdW5jdGlvblRlbXBsYXRlJztcblxuaW1wb3J0IHsgQWJzdHJhY3RDdXN0b21Ob2RlIH0gZnJvbSAnLi4vQWJzdHJhY3RDdXN0b21Ob2RlJztcbmltcG9ydCB7IEphdmFTY3JpcHRPYmZ1c2NhdG9yIH0gZnJvbSAnLi4vLi4vSmF2YVNjcmlwdE9iZnVzY2F0b3InO1xuaW1wb3J0IHsgTm9kZVV0aWxzIH0gZnJvbSAnLi4vLi4vbm9kZS9Ob2RlVXRpbHMnO1xuaW1wb3J0IHsgVXRpbHMgfSBmcm9tICcuLi8uLi91dGlscy9VdGlscyc7XG5cbkBpbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBTdHJpbmdBcnJheVJvdGF0ZUZ1bmN0aW9uTm9kZSBleHRlbmRzIEFic3RyYWN0Q3VzdG9tTm9kZSB7XG4gICAgLyoqXG4gICAgICogQHR5cGUge0lFc2NhcGVTZXF1ZW5jZUVuY29kZXJ9XG4gICAgICovXG4gICAgcHJpdmF0ZSByZWFkb25seSBlc2NhcGVTZXF1ZW5jZUVuY29kZXI6IElFc2NhcGVTZXF1ZW5jZUVuY29kZXI7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7SVJhbmRvbUdlbmVyYXRvcn1cbiAgICAgKi9cbiAgICBwcml2YXRlIHJlYWRvbmx5IHJhbmRvbUdlbmVyYXRvcjogSVJhbmRvbUdlbmVyYXRvcjtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtJU3RvcmFnZSA8c3RyaW5nPn1cbiAgICAgKi9cbiAgICBAaW5pdGlhbGl6YWJsZSgpXG4gICAgcHJpdmF0ZSBzdHJpbmdBcnJheVN0b3JhZ2U6IElTdG9yYWdlIDxzdHJpbmc+O1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICBAaW5pdGlhbGl6YWJsZSgpXG4gICAgcHJpdmF0ZSBzdHJpbmdBcnJheU5hbWU6IHN0cmluZztcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfVxuICAgICAqL1xuICAgIEBpbml0aWFsaXphYmxlKClcbiAgICBwcml2YXRlIHN0cmluZ0FycmF5Um90YXRlVmFsdWU6IG51bWJlcjtcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7SVJhbmRvbUdlbmVyYXRvcn0gcmFuZG9tR2VuZXJhdG9yXG4gICAgICogQHBhcmFtIHtJRXNjYXBlU2VxdWVuY2VFbmNvZGVyfSBlc2NhcGVTZXF1ZW5jZUVuY29kZXJcbiAgICAgKiBAcGFyYW0ge0lPcHRpb25zfSBvcHRpb25zXG4gICAgICovXG4gICAgY29uc3RydWN0b3IgKFxuICAgICAgICBAaW5qZWN0KFNlcnZpY2VJZGVudGlmaWVycy5JUmFuZG9tR2VuZXJhdG9yKSByYW5kb21HZW5lcmF0b3I6IElSYW5kb21HZW5lcmF0b3IsXG4gICAgICAgIEBpbmplY3QoU2VydmljZUlkZW50aWZpZXJzLklFc2NhcGVTZXF1ZW5jZUVuY29kZXIpIGVzY2FwZVNlcXVlbmNlRW5jb2RlcjogSUVzY2FwZVNlcXVlbmNlRW5jb2RlcixcbiAgICAgICAgQGluamVjdChTZXJ2aWNlSWRlbnRpZmllcnMuSU9wdGlvbnMpIG9wdGlvbnM6IElPcHRpb25zXG4gICAgKSB7XG4gICAgICAgIHN1cGVyKG9wdGlvbnMpO1xuXG4gICAgICAgIHRoaXMucmFuZG9tR2VuZXJhdG9yID0gcmFuZG9tR2VuZXJhdG9yO1xuICAgICAgICB0aGlzLmVzY2FwZVNlcXVlbmNlRW5jb2RlciA9IGVzY2FwZVNlcXVlbmNlRW5jb2RlcjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0lTdG9yYWdlPHN0cmluZz59IHN0cmluZ0FycmF5U3RvcmFnZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmdBcnJheU5hbWVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc3RyaW5nQXJyYXlSb3RhdGVWYWx1ZVxuICAgICAqL1xuICAgIHB1YmxpYyBpbml0aWFsaXplIChcbiAgICAgICAgc3RyaW5nQXJyYXlTdG9yYWdlOiBJU3RvcmFnZSA8c3RyaW5nPixcbiAgICAgICAgc3RyaW5nQXJyYXlOYW1lOiBzdHJpbmcsXG4gICAgICAgIHN0cmluZ0FycmF5Um90YXRlVmFsdWU6IG51bWJlclxuICAgICk6IHZvaWQge1xuICAgICAgICB0aGlzLnN0cmluZ0FycmF5U3RvcmFnZSA9IHN0cmluZ0FycmF5U3RvcmFnZTtcbiAgICAgICAgdGhpcy5zdHJpbmdBcnJheU5hbWUgPSBzdHJpbmdBcnJheU5hbWU7XG4gICAgICAgIHRoaXMuc3RyaW5nQXJyYXlSb3RhdGVWYWx1ZSA9IHN0cmluZ0FycmF5Um90YXRlVmFsdWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMge1RTdGF0ZW1lbnRbXX1cbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgZ2V0Tm9kZVN0cnVjdHVyZSAoKTogVFN0YXRlbWVudFtdIHtcbiAgICAgICAgcmV0dXJuIE5vZGVVdGlscy5jb252ZXJ0Q29kZVRvU3RydWN0dXJlKHRoaXMuZ2V0VGVtcGxhdGUoKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgZ2V0VGVtcGxhdGUgKCk6IHN0cmluZyB7XG4gICAgICAgIGNvbnN0IHRpbWVzTmFtZTogc3RyaW5nID0gdGhpcy5yYW5kb21HZW5lcmF0b3IuZ2V0UmFuZG9tVmFyaWFibGVOYW1lKDYpO1xuICAgICAgICBjb25zdCB3aGlsZUZ1bmN0aW9uTmFtZTogc3RyaW5nID0gdGhpcy5yYW5kb21HZW5lcmF0b3IuZ2V0UmFuZG9tVmFyaWFibGVOYW1lKDYpO1xuXG4gICAgICAgIGxldCBjb2RlOiBzdHJpbmcgPSAnJztcblxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnNlbGZEZWZlbmRpbmcpIHtcbiAgICAgICAgICAgIGNvZGUgPSBmb3JtYXQoU2VsZkRlZmVuZGluZ1RlbXBsYXRlKHRoaXMuZXNjYXBlU2VxdWVuY2VFbmNvZGVyKSwge1xuICAgICAgICAgICAgICAgIHRpbWVzTmFtZSxcbiAgICAgICAgICAgICAgICB3aGlsZUZ1bmN0aW9uTmFtZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb2RlID0gYCR7d2hpbGVGdW5jdGlvbk5hbWV9KCsrJHt0aW1lc05hbWV9KWA7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gSmF2YVNjcmlwdE9iZnVzY2F0b3Iub2JmdXNjYXRlKFxuICAgICAgICAgICAgZm9ybWF0KFN0cmluZ0FycmF5Um90YXRlRnVuY3Rpb25UZW1wbGF0ZSgpLCB7XG4gICAgICAgICAgICAgICAgY29kZSxcbiAgICAgICAgICAgICAgICB0aW1lc05hbWUsXG4gICAgICAgICAgICAgICAgc3RyaW5nQXJyYXlOYW1lOiB0aGlzLnN0cmluZ0FycmF5TmFtZSxcbiAgICAgICAgICAgICAgICBzdHJpbmdBcnJheVJvdGF0ZVZhbHVlOiBVdGlscy5kZWNUb0hleCh0aGlzLnN0cmluZ0FycmF5Um90YXRlVmFsdWUpLFxuICAgICAgICAgICAgICAgIHdoaWxlRnVuY3Rpb25OYW1lXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAuLi5OT19DVVNUT01fTk9ERVNfUFJFU0VULFxuICAgICAgICAgICAgICAgIHNlZWQ6IHRoaXMub3B0aW9ucy5zZWVkXG4gICAgICAgICAgICB9XG4gICAgICAgICkuZ2V0T2JmdXNjYXRlZENvZGUoKTtcbiAgICB9XG59XG4iXX0=