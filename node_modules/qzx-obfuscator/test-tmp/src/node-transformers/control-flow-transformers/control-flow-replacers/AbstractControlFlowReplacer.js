"use strict";

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var inversify_1 = require("inversify");
var ServiceIdentifiers_1 = require("../../../container/ServiceIdentifiers");
var AbstractControlFlowReplacer = AbstractControlFlowReplacer_1 = function () {
    function AbstractControlFlowReplacer(controlFlowCustomNodeFactory, randomGenerator, options) {
        _classCallCheck(this, AbstractControlFlowReplacer);

        this.replacerDataByControlFlowStorageId = new Map();
        this.controlFlowCustomNodeFactory = controlFlowCustomNodeFactory;
        this.randomGenerator = randomGenerator;
        this.options = options;
    }

    _createClass(AbstractControlFlowReplacer, [{
        key: "insertCustomNodeToControlFlowStorage",
        value: function insertCustomNodeToControlFlowStorage(customNode, controlFlowStorage, replacerId, usingExistingIdentifierChance) {
            var _this = this;

            var controlFlowStorageId = controlFlowStorage.getStorageId();
            var storageKeysById = AbstractControlFlowReplacer_1.getStorageKeysByIdForCurrentStorage(this.replacerDataByControlFlowStorageId, controlFlowStorageId);
            var storageKeysForCurrentId = storageKeysById.get(replacerId);
            if (this.randomGenerator.getMathRandom() < usingExistingIdentifierChance && storageKeysForCurrentId && storageKeysForCurrentId.length) {
                return this.randomGenerator.getRandomGenerator().pickone(storageKeysForCurrentId);
            }
            var generateStorageKey = function generateStorageKey(length) {
                var key = _this.randomGenerator.getRandomString(length);
                if (controlFlowStorage.getStorage().has(key)) {
                    return generateStorageKey(length);
                }
                return key;
            };
            var storageKey = generateStorageKey(5);
            storageKeysById.set(replacerId, [storageKey]);
            this.replacerDataByControlFlowStorageId.set(controlFlowStorageId, storageKeysById);
            controlFlowStorage.set(storageKey, customNode);
            return storageKey;
        }
    }], [{
        key: "getStorageKeysByIdForCurrentStorage",
        value: function getStorageKeysByIdForCurrentStorage(identifierDataByControlFlowStorageId, controlFlowStorageId) {
            var storageKeysById = void 0;
            if (identifierDataByControlFlowStorageId.has(controlFlowStorageId)) {
                storageKeysById = identifierDataByControlFlowStorageId.get(controlFlowStorageId);
            } else {
                storageKeysById = new Map();
            }
            return storageKeysById;
        }
    }]);

    return AbstractControlFlowReplacer;
}();
AbstractControlFlowReplacer = AbstractControlFlowReplacer_1 = tslib_1.__decorate([inversify_1.injectable(), tslib_1.__param(0, inversify_1.inject(ServiceIdentifiers_1.ServiceIdentifiers.Factory__IControlFlowCustomNode)), tslib_1.__param(1, inversify_1.inject(ServiceIdentifiers_1.ServiceIdentifiers.IRandomGenerator)), tslib_1.__param(2, inversify_1.inject(ServiceIdentifiers_1.ServiceIdentifiers.IOptions)), tslib_1.__metadata("design:paramtypes", [Function, Object, Object])], AbstractControlFlowReplacer);
exports.AbstractControlFlowReplacer = AbstractControlFlowReplacer;
var AbstractControlFlowReplacer_1;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQWJzdHJhY3RDb250cm9sRmxvd1JlcGxhY2VyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vc3JjL25vZGUtdHJhbnNmb3JtZXJzL2NvbnRyb2wtZmxvdy10cmFuc2Zvcm1lcnMvY29udHJvbC1mbG93LXJlcGxhY2Vycy9BYnN0cmFjdENvbnRyb2xGbG93UmVwbGFjZXIudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQSwwQkFBK0M7QUFDL0MsbUNBQTJFO0FBYTNFLElBQXNCLEFBQTJCO0FBMEI3Qyx5Q0FFUSxBQUEyRCw4QkFDbEIsQUFBaUMsaUJBQ3pDLEFBQWlCOzs7QUFYdkMsYUFBa0MscUNBQXdDLElBQUksQUFBRyxBQUFFLEFBQUM7QUFhbkcsQUFBSSxhQUFDLEFBQTRCLCtCQUFHLEFBQTRCLEFBQUM7QUFDakUsQUFBSSxhQUFDLEFBQWUsa0JBQUcsQUFBZSxBQUFDO0FBQ3ZDLEFBQUksYUFBQyxBQUFPLFVBQUcsQUFBTyxBQUFDLEFBQzNCO0FBQUMsQUFPUyxBQUFNLEFBQUMsQUFBbUM7O0FBMUN4RDs7NkRBeUVRLEFBQXVCLFlBQ3ZCLEFBQTBDLG9CQUMxQyxBQUFrQixZQUNsQixBQUFxQzs7O0FBRXJDLGdCQUFNLEFBQW9CLHVCQUFXLEFBQWtCLG1CQUFDLEFBQVksQUFBRSxBQUFDO0FBQ3ZFLGdCQUFNLEFBQWUsa0JBQTBCLEFBQTJCLDhCQUNyRSxBQUFtQyxvQ0FBQyxBQUFJLEtBQUMsQUFBa0Msb0NBQUUsQUFBb0IsQUFBQyxBQUFDO0FBQ3hHLGdCQUFNLEFBQXVCLDBCQUF5QixBQUFlLGdCQUFDLEFBQUcsSUFBQyxBQUFVLEFBQUMsQUFBQztBQUV0RixBQUFFLEFBQUMsZ0JBQ0MsQUFBSSxLQUFDLEFBQWUsZ0JBQUMsQUFBYSxBQUFFLGtCQUFHLEFBQTZCLGlDQUNwRSxBQUF1QiwyQkFDdkIsQUFBdUIsd0JBQUMsQUFDNUIsQUFBQyxRQUFDLEFBQUM7QUFDQyxBQUFNLHVCQUFDLEFBQUksS0FBQyxBQUFlLGdCQUFDLEFBQWtCLEFBQUUscUJBQUMsQUFBTyxRQUFDLEFBQXVCLEFBQUMsQUFBQyxBQUN0RjtBQUFDO0FBRUQsZ0JBQU0sQUFBa0IscUJBQStCLDRCQUFDLEFBQWM7QUFDbEUsb0JBQU0sQUFBRyxNQUFXLEFBQUksTUFBQyxBQUFlLGdCQUFDLEFBQWUsZ0JBQUMsQUFBTSxBQUFDLEFBQUM7QUFFakUsQUFBRSxBQUFDLG9CQUFDLEFBQWtCLG1CQUFDLEFBQVUsQUFBRSxhQUFDLEFBQUcsSUFBQyxBQUFHLEFBQUMsQUFBQyxNQUFDLEFBQUM7QUFDM0MsQUFBTSwyQkFBQyxBQUFrQixtQkFBQyxBQUFNLEFBQUMsQUFBQyxBQUN0QztBQUFDO0FBRUQsQUFBTSx1QkFBQyxBQUFHLEFBQUMsQUFDZjtBQUFDLEFBQUM7QUFDRixnQkFBTSxBQUFVLGFBQVcsQUFBa0IsbUJBQUMsQUFBQyxBQUFDLEFBQUM7QUFFakQsQUFBZSw0QkFBQyxBQUFHLElBQUMsQUFBVSxZQUFFLENBQUMsQUFBVSxBQUFDLEFBQUMsQUFBQztBQUM5QyxBQUFJLGlCQUFDLEFBQWtDLG1DQUFDLEFBQUcsSUFBQyxBQUFvQixzQkFBRSxBQUFlLEFBQUMsQUFBQztBQUNuRixBQUFrQiwrQkFBQyxBQUFHLElBQUMsQUFBVSxZQUFFLEFBQVUsQUFBQyxBQUFDO0FBRS9DLEFBQU0sbUJBQUMsQUFBVSxBQUFDLEFBQ3RCO0FBQUMsQUFDSjs7OzREQWpFTyxBQUF3RSxzQ0FDeEUsQUFBNEI7QUFFNUIsZ0JBQUksQUFBc0MsQUFBQztBQUUzQyxBQUFFLEFBQUMsZ0JBQUMsQUFBb0MscUNBQUMsQUFBRyxJQUFDLEFBQW9CLEFBQUMsQUFBQyx1QkFBQyxBQUFDO0FBQ2pFLEFBQWUsa0NBQTBCLEFBQW9DLHFDQUFDLEFBQUcsSUFBQyxBQUFvQixBQUFDLEFBQUMsQUFDNUc7QUFBQyxBQUFDLEFBQUksbUJBQUMsQUFBQztBQUNKLEFBQWUsa0NBQUcsSUFBSSxBQUFHLEFBQXFCLEFBQUMsQUFDbkQ7QUFBQztBQUVELEFBQU0sbUJBQUMsQUFBZSxBQUFDLEFBQzNCO0FBQUMsQUFpQlMsQUFBb0M7Ozs7O0FBeEU1QixBQUEyQixrRkFEaEQsWUFBVSxBQUFFLGNBNEJKLG1CQUFBLFlBQU0sT0FBQyxxQkFBa0IsbUJBQUMsQUFBK0IsQUFBQyxtQ0FFMUQsbUJBQUEsWUFBTSxPQUFDLHFCQUFrQixtQkFBQyxBQUFnQixBQUFDLG9CQUMzQyxtQkFBQSxZQUFNLE9BQUMscUJBQWtCLG1CQUFDLEFBQVEsQUFBQyxrRkE5QnRCLEFBQTJCLEFBNEdoRDtBQTVHcUIsc0NBQTJCIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgaW5qZWN0YWJsZSwgaW5qZWN0IH0gZnJvbSAnaW52ZXJzaWZ5JztcbmltcG9ydCB7IFNlcnZpY2VJZGVudGlmaWVycyB9IGZyb20gJy4uLy4uLy4uL2NvbnRhaW5lci9TZXJ2aWNlSWRlbnRpZmllcnMnO1xuXG5pbXBvcnQgKiBhcyBFU1RyZWUgZnJvbSAnZXN0cmVlJztcblxuaW1wb3J0IHsgVENvbnRyb2xGbG93Q3VzdG9tTm9kZUZhY3RvcnkgfSBmcm9tICcuLi8uLi8uLi90eXBlcy9jb250YWluZXIvY3VzdG9tLW5vZGVzL1RDb250cm9sRmxvd0N1c3RvbU5vZGVGYWN0b3J5JztcblxuaW1wb3J0IHsgSUNvbnRyb2xGbG93UmVwbGFjZXIgfSBmcm9tICcuLi8uLi8uLi9pbnRlcmZhY2VzL25vZGUtdHJhbnNmb3JtZXJzL2NvbnRyb2wtZmxvdy10cmFuc2Zvcm1lcnMvSUNvbnRyb2xGbG93UmVwbGFjZXInO1xuaW1wb3J0IHsgSUN1c3RvbU5vZGUgfSBmcm9tICcuLi8uLi8uLi9pbnRlcmZhY2VzL2N1c3RvbS1ub2Rlcy9JQ3VzdG9tTm9kZSc7XG5pbXBvcnQgeyBJT3B0aW9ucyB9IGZyb20gJy4uLy4uLy4uL2ludGVyZmFjZXMvb3B0aW9ucy9JT3B0aW9ucyc7XG5pbXBvcnQgeyBJUmFuZG9tR2VuZXJhdG9yIH0gZnJvbSAnLi4vLi4vLi4vaW50ZXJmYWNlcy91dGlscy9JUmFuZG9tR2VuZXJhdG9yJztcbmltcG9ydCB7IElTdG9yYWdlIH0gZnJvbSAnLi4vLi4vLi4vaW50ZXJmYWNlcy9zdG9yYWdlcy9JU3RvcmFnZSc7XG5cbkBpbmplY3RhYmxlKClcbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBBYnN0cmFjdENvbnRyb2xGbG93UmVwbGFjZXIgaW1wbGVtZW50cyBJQ29udHJvbEZsb3dSZXBsYWNlciB7XG4gICAgLyoqXG4gICAgICogQHR5cGUge1RDb250cm9sRmxvd0N1c3RvbU5vZGVGYWN0b3J5fVxuICAgICAqL1xuICAgIHByb3RlY3RlZCByZWFkb25seSBjb250cm9sRmxvd0N1c3RvbU5vZGVGYWN0b3J5OiBUQ29udHJvbEZsb3dDdXN0b21Ob2RlRmFjdG9yeTtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtJT3B0aW9uc31cbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgcmVhZG9ubHkgb3B0aW9uczogSU9wdGlvbnM7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7SVJhbmRvbUdlbmVyYXRvcn1cbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgcmVhZG9ubHkgcmFuZG9tR2VuZXJhdG9yOiBJUmFuZG9tR2VuZXJhdG9yO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge01hcDxzdHJpbmcsIE1hcDxzdHJpbmcsIHN0cmluZ1tdPj59XG4gICAgICovXG4gICAgcHJvdGVjdGVkIHJlYWRvbmx5IHJlcGxhY2VyRGF0YUJ5Q29udHJvbEZsb3dTdG9yYWdlSWQ6IE1hcCA8c3RyaW5nLCBNYXA8c3RyaW5nLCBzdHJpbmdbXT4+ID0gbmV3IE1hcCgpO1xuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtUQ29udHJvbEZsb3dDdXN0b21Ob2RlRmFjdG9yeX0gY29udHJvbEZsb3dDdXN0b21Ob2RlRmFjdG9yeVxuICAgICAqIEBwYXJhbSB7SVJhbmRvbUdlbmVyYXRvcn0gcmFuZG9tR2VuZXJhdG9yXG4gICAgICogQHBhcmFtIHtJT3B0aW9uc30gb3B0aW9uc1xuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yIChcbiAgICAgICAgQGluamVjdChTZXJ2aWNlSWRlbnRpZmllcnMuRmFjdG9yeV9fSUNvbnRyb2xGbG93Q3VzdG9tTm9kZSlcbiAgICAgICAgICAgIGNvbnRyb2xGbG93Q3VzdG9tTm9kZUZhY3Rvcnk6IFRDb250cm9sRmxvd0N1c3RvbU5vZGVGYWN0b3J5LFxuICAgICAgICBAaW5qZWN0KFNlcnZpY2VJZGVudGlmaWVycy5JUmFuZG9tR2VuZXJhdG9yKSByYW5kb21HZW5lcmF0b3I6IElSYW5kb21HZW5lcmF0b3IsXG4gICAgICAgIEBpbmplY3QoU2VydmljZUlkZW50aWZpZXJzLklPcHRpb25zKSBvcHRpb25zOiBJT3B0aW9uc1xuICAgICkge1xuICAgICAgICB0aGlzLmNvbnRyb2xGbG93Q3VzdG9tTm9kZUZhY3RvcnkgPSBjb250cm9sRmxvd0N1c3RvbU5vZGVGYWN0b3J5O1xuICAgICAgICB0aGlzLnJhbmRvbUdlbmVyYXRvciA9IHJhbmRvbUdlbmVyYXRvcjtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge01hcDxzdHJpbmcsIE1hcDxzdHJpbmcsIHN0cmluZ1tdPj59IGlkZW50aWZpZXJEYXRhQnlDb250cm9sRmxvd1N0b3JhZ2VJZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjb250cm9sRmxvd1N0b3JhZ2VJZFxuICAgICAqIEByZXR1cm5zIHtNYXA8c3RyaW5nLCBzdHJpbmdbXT59XG4gICAgICovXG4gICAgcHJvdGVjdGVkIHN0YXRpYyBnZXRTdG9yYWdlS2V5c0J5SWRGb3JDdXJyZW50U3RvcmFnZSAoXG4gICAgICAgIGlkZW50aWZpZXJEYXRhQnlDb250cm9sRmxvd1N0b3JhZ2VJZDogTWFwPHN0cmluZywgTWFwPHN0cmluZywgc3RyaW5nW10+PixcbiAgICAgICAgY29udHJvbEZsb3dTdG9yYWdlSWQ6IHN0cmluZ1xuICAgICk6IE1hcDxzdHJpbmcsIHN0cmluZ1tdPiB7XG4gICAgICAgIGxldCBzdG9yYWdlS2V5c0J5SWQ6IE1hcDxzdHJpbmcsIHN0cmluZ1tdPjtcblxuICAgICAgICBpZiAoaWRlbnRpZmllckRhdGFCeUNvbnRyb2xGbG93U3RvcmFnZUlkLmhhcyhjb250cm9sRmxvd1N0b3JhZ2VJZCkpIHtcbiAgICAgICAgICAgIHN0b3JhZ2VLZXlzQnlJZCA9IDxNYXA8c3RyaW5nLCBzdHJpbmdbXT4+aWRlbnRpZmllckRhdGFCeUNvbnRyb2xGbG93U3RvcmFnZUlkLmdldChjb250cm9sRmxvd1N0b3JhZ2VJZCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdG9yYWdlS2V5c0J5SWQgPSBuZXcgTWFwIDxzdHJpbmcsIHN0cmluZ1tdPigpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHN0b3JhZ2VLZXlzQnlJZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge05vZGV9IG5vZGVcbiAgICAgKiBAcGFyYW0ge05vZGV9IHBhcmVudE5vZGVcbiAgICAgKiBAcGFyYW0ge0lTdG9yYWdlPElDdXN0b21Ob2RlPn0gY29udHJvbEZsb3dTdG9yYWdlXG4gICAgICogQHJldHVybnMge05vZGV9XG4gICAgICovXG4gICAgcHVibGljIGFic3RyYWN0IHJlcGxhY2UgKG5vZGU6IEVTVHJlZS5Ob2RlLCBwYXJlbnROb2RlOiBFU1RyZWUuTm9kZSwgY29udHJvbEZsb3dTdG9yYWdlOiBJU3RvcmFnZSA8SUN1c3RvbU5vZGU+KTogRVNUcmVlLk5vZGU7XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0lDdXN0b21Ob2RlfSBjdXN0b21Ob2RlXG4gICAgICogQHBhcmFtIHtJU3RvcmFnZTxJQ3VzdG9tTm9kZT59IGNvbnRyb2xGbG93U3RvcmFnZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSByZXBsYWNlcklkXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHVzaW5nRXhpc3RpbmdJZGVudGlmaWVyQ2hhbmNlXG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgaW5zZXJ0Q3VzdG9tTm9kZVRvQ29udHJvbEZsb3dTdG9yYWdlIChcbiAgICAgICAgY3VzdG9tTm9kZTogSUN1c3RvbU5vZGUsXG4gICAgICAgIGNvbnRyb2xGbG93U3RvcmFnZTogSVN0b3JhZ2UgPElDdXN0b21Ob2RlPixcbiAgICAgICAgcmVwbGFjZXJJZDogc3RyaW5nLFxuICAgICAgICB1c2luZ0V4aXN0aW5nSWRlbnRpZmllckNoYW5jZTogbnVtYmVyXG4gICAgKTogc3RyaW5nIHtcbiAgICAgICAgY29uc3QgY29udHJvbEZsb3dTdG9yYWdlSWQ6IHN0cmluZyA9IGNvbnRyb2xGbG93U3RvcmFnZS5nZXRTdG9yYWdlSWQoKTtcbiAgICAgICAgY29uc3Qgc3RvcmFnZUtleXNCeUlkOiBNYXA8c3RyaW5nLCBzdHJpbmdbXT4gPSBBYnN0cmFjdENvbnRyb2xGbG93UmVwbGFjZXJcbiAgICAgICAgICAgIC5nZXRTdG9yYWdlS2V5c0J5SWRGb3JDdXJyZW50U3RvcmFnZSh0aGlzLnJlcGxhY2VyRGF0YUJ5Q29udHJvbEZsb3dTdG9yYWdlSWQsIGNvbnRyb2xGbG93U3RvcmFnZUlkKTtcbiAgICAgICAgY29uc3Qgc3RvcmFnZUtleXNGb3JDdXJyZW50SWQ6IHN0cmluZ1tdIHwgdW5kZWZpbmVkID0gc3RvcmFnZUtleXNCeUlkLmdldChyZXBsYWNlcklkKTtcblxuICAgICAgICBpZiAoXG4gICAgICAgICAgICB0aGlzLnJhbmRvbUdlbmVyYXRvci5nZXRNYXRoUmFuZG9tKCkgPCB1c2luZ0V4aXN0aW5nSWRlbnRpZmllckNoYW5jZSAmJlxuICAgICAgICAgICAgc3RvcmFnZUtleXNGb3JDdXJyZW50SWQgJiZcbiAgICAgICAgICAgIHN0b3JhZ2VLZXlzRm9yQ3VycmVudElkLmxlbmd0aFxuICAgICAgICApIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJhbmRvbUdlbmVyYXRvci5nZXRSYW5kb21HZW5lcmF0b3IoKS5waWNrb25lKHN0b3JhZ2VLZXlzRm9yQ3VycmVudElkKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGdlbmVyYXRlU3RvcmFnZUtleTogKGxlbmd0aDogbnVtYmVyKSA9PiBzdHJpbmcgPSAobGVuZ3RoOiBudW1iZXIpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGtleTogc3RyaW5nID0gdGhpcy5yYW5kb21HZW5lcmF0b3IuZ2V0UmFuZG9tU3RyaW5nKGxlbmd0aCk7XG5cbiAgICAgICAgICAgIGlmIChjb250cm9sRmxvd1N0b3JhZ2UuZ2V0U3RvcmFnZSgpLmhhcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGdlbmVyYXRlU3RvcmFnZUtleShsZW5ndGgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4ga2V5O1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBzdG9yYWdlS2V5OiBzdHJpbmcgPSBnZW5lcmF0ZVN0b3JhZ2VLZXkoNSk7XG5cbiAgICAgICAgc3RvcmFnZUtleXNCeUlkLnNldChyZXBsYWNlcklkLCBbc3RvcmFnZUtleV0pO1xuICAgICAgICB0aGlzLnJlcGxhY2VyRGF0YUJ5Q29udHJvbEZsb3dTdG9yYWdlSWQuc2V0KGNvbnRyb2xGbG93U3RvcmFnZUlkLCBzdG9yYWdlS2V5c0J5SWQpO1xuICAgICAgICBjb250cm9sRmxvd1N0b3JhZ2Uuc2V0KHN0b3JhZ2VLZXksIGN1c3RvbU5vZGUpO1xuXG4gICAgICAgIHJldHVybiBzdG9yYWdlS2V5O1xuICAgIH1cbn1cbiJdfQ==