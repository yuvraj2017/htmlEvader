"use strict";

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var inversify_1 = require("inversify");
var ServiceIdentifiers_1 = require("../../../container/ServiceIdentifiers");
var ControlFlowCustomNode_1 = require("../../../enums/container/custom-nodes/ControlFlowCustomNode");
var AbstractControlFlowReplacer_1 = require("./AbstractControlFlowReplacer");
var Node_1 = require("../../../node/Node");
var CallExpressionControlFlowReplacer = CallExpressionControlFlowReplacer_1 = function (_AbstractControlFlowR) {
    _inherits(CallExpressionControlFlowReplacer, _AbstractControlFlowR);

    function CallExpressionControlFlowReplacer(controlFlowCustomNodeFactory, randomGenerator, options) {
        _classCallCheck(this, CallExpressionControlFlowReplacer);

        return _possibleConstructorReturn(this, (CallExpressionControlFlowReplacer.__proto__ || Object.getPrototypeOf(CallExpressionControlFlowReplacer)).call(this, controlFlowCustomNodeFactory, randomGenerator, options));
    }

    _createClass(CallExpressionControlFlowReplacer, [{
        key: "replace",
        value: function replace(callExpressionNode, parentNode, controlFlowStorage) {
            var callee = callExpressionNode.callee;
            if (!Node_1.Node.isIdentifierNode(callee)) {
                return callExpressionNode;
            }
            var replacerId = String(callExpressionNode.arguments.length);
            var callExpressionFunctionCustomNode = this.controlFlowCustomNodeFactory(ControlFlowCustomNode_1.ControlFlowCustomNode.CallExpressionFunctionNode);
            var expressionArguments = callExpressionNode.arguments;
            callExpressionFunctionCustomNode.initialize(expressionArguments);
            var storageKey = this.insertCustomNodeToControlFlowStorage(callExpressionFunctionCustomNode, controlFlowStorage, replacerId, CallExpressionControlFlowReplacer_1.usingExistingIdentifierChance);
            return this.getControlFlowStorageCallNode(controlFlowStorage.getStorageId(), storageKey, callee, expressionArguments);
        }
    }, {
        key: "getControlFlowStorageCallNode",
        value: function getControlFlowStorageCallNode(controlFlowStorageId, storageKey, callee, expressionArguments) {
            var controlFlowStorageCallCustomNode = this.controlFlowCustomNodeFactory(ControlFlowCustomNode_1.ControlFlowCustomNode.CallExpressionControlFlowStorageCallNode);
            controlFlowStorageCallCustomNode.initialize(controlFlowStorageId, storageKey, callee, expressionArguments);
            var statementNode = controlFlowStorageCallCustomNode.getNode()[0];
            if (!statementNode || !Node_1.Node.isExpressionStatementNode(statementNode)) {
                throw new Error("`controlFlowStorageCallCustomNode.getNode()[0]` should returns array with `ExpressionStatement` node");
            }
            return statementNode.expression;
        }
    }]);

    return CallExpressionControlFlowReplacer;
}(AbstractControlFlowReplacer_1.AbstractControlFlowReplacer);
CallExpressionControlFlowReplacer.usingExistingIdentifierChance = 0.5;
CallExpressionControlFlowReplacer = CallExpressionControlFlowReplacer_1 = tslib_1.__decorate([inversify_1.injectable(), tslib_1.__param(0, inversify_1.inject(ServiceIdentifiers_1.ServiceIdentifiers.Factory__IControlFlowCustomNode)), tslib_1.__param(1, inversify_1.inject(ServiceIdentifiers_1.ServiceIdentifiers.IRandomGenerator)), tslib_1.__param(2, inversify_1.inject(ServiceIdentifiers_1.ServiceIdentifiers.IOptions)), tslib_1.__metadata("design:paramtypes", [Function, Object, Object])], CallExpressionControlFlowReplacer);
exports.CallExpressionControlFlowReplacer = CallExpressionControlFlowReplacer;
var CallExpressionControlFlowReplacer_1;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQ2FsbEV4cHJlc3Npb25Db250cm9sRmxvd1JlcGxhY2VyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vc3JjL25vZGUtdHJhbnNmb3JtZXJzL2NvbnRyb2wtZmxvdy10cmFuc2Zvcm1lcnMvY29udHJvbC1mbG93LXJlcGxhY2Vycy9DYWxsRXhwcmVzc2lvbkNvbnRyb2xGbG93UmVwbGFjZXIudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQUEsMEJBQStDO0FBQy9DLG1DQUEyRTtBQVkzRSxzQ0FBb0c7QUFFcEcsNENBQTRFO0FBQzVFLHFCQUEwQztBQUcxQyxJQUFhLEFBQWlDO0FBQTlDLEFBQStDOztBQVczQywrQ0FFUSxBQUEyRCw4QkFDbEIsQUFBaUMsaUJBQ3pDLEFBQWlCO0FBRXRELEFBQUs7O3FLQUFDLEFBQTRCLDhCQUFFLEFBQWUsaUJBQUUsQUFBTyxBQUFDLEFBQUMsQUFDbEU7QUFBQyxBQVFNLEFBQU87Ozs7Z0NBQ1YsQUFBeUMsb0JBQ3pDLEFBQXVCLFlBQ3ZCLEFBQTBDO0FBRTFDLGdCQUFNLEFBQU0sU0FBeUMsQUFBa0IsbUJBQUMsQUFBTSxBQUFDO0FBRS9FLEFBQUUsQUFBQyxnQkFBQyxDQUFDLE9BQUksS0FBQyxBQUFnQixpQkFBQyxBQUFNLEFBQUMsQUFBQyxTQUFDLEFBQUM7QUFDakMsQUFBTSx1QkFBQyxBQUFrQixBQUFDLEFBQzlCO0FBQUM7QUFFRCxnQkFBTSxBQUFVLGFBQVcsQUFBTSxPQUFDLEFBQWtCLG1CQUFDLEFBQVMsVUFBQyxBQUFNLEFBQUMsQUFBQztBQUN2RSxnQkFBTSxBQUFnQyxtQ0FBZ0IsQUFBSSxLQUFDLEFBQTRCLDZCQUNuRix3QkFBcUIsc0JBQUMsQUFBMEIsQUFDbkQsQUFBQztBQUNGLGdCQUFNLEFBQW1CLHNCQUFpRCxBQUFrQixtQkFBQyxBQUFTLEFBQUM7QUFFdkcsQUFBZ0MsNkNBQUMsQUFBVSxXQUFDLEFBQW1CLEFBQUMsQUFBQztBQUVqRSxnQkFBTSxBQUFVLGFBQVcsQUFBSSxLQUFDLEFBQW9DLHFDQUNoRSxBQUFnQyxrQ0FDaEMsQUFBa0Isb0JBQ2xCLEFBQVUsWUFDVixBQUFpQyxvQ0FBQyxBQUE2QixBQUNsRSxBQUFDO0FBRUYsQUFBTSxtQkFBQyxBQUFJLEtBQUMsQUFBNkIsOEJBQ3JDLEFBQWtCLG1CQUFDLEFBQVksQUFBRSxnQkFDakMsQUFBVSxZQUNWLEFBQU0sUUFDTixBQUFtQixBQUN0QixBQUFDLEFBQ047QUFBQyxBQVNTLEFBQTZCOzs7c0RBQ25DLEFBQTRCLHNCQUM1QixBQUFrQixZQUNsQixBQUF5QixRQUN6QixBQUFpRTtBQUVqRSxnQkFBTSxBQUFnQyxtQ0FBZ0IsQUFBSSxLQUFDLEFBQTRCLDZCQUNuRix3QkFBcUIsc0JBQUMsQUFBd0MsQUFDakUsQUFBQztBQUVGLEFBQWdDLDZDQUFDLEFBQVUsV0FBQyxBQUFvQixzQkFBRSxBQUFVLFlBQUUsQUFBTSxRQUFFLEFBQW1CLEFBQUMsQUFBQztBQUUzRyxnQkFBTSxBQUFhLGdCQUFlLEFBQWdDLGlDQUFDLEFBQU8sQUFBRSxVQUFDLEFBQUMsQUFBQyxBQUFDO0FBRWhGLEFBQUUsQUFBQyxnQkFBQyxDQUFDLEFBQWEsaUJBQUksQ0FBQyxPQUFJLEtBQUMsQUFBeUIsMEJBQUMsQUFBYSxBQUFDLEFBQUMsZ0JBQUMsQUFBQztBQUNuRSxzQkFBTSxJQUFJLEFBQUssQUFBQyxBQUEwRyxBQUFDLEFBQUMsQUFDaEk7QUFBQztBQUVELEFBQU0sbUJBQUMsQUFBYSxjQUFDLEFBQVUsQUFBQyxBQUNwQztBQUFDLEFBQ0o7Ozs7RUF2RnNELDhCQUEyQjtBQUl0RCxrQ0FBNkIsZ0NBQVcsQUFBRyxBQUFDO0FBSjNELEFBQWlDLDhGQUQ3QyxZQUFVLEFBQUUsY0FhSixtQkFBQSxZQUFNLE9BQUMscUJBQWtCLG1CQUFDLEFBQStCLEFBQUMsbUNBRTFELG1CQUFBLFlBQU0sT0FBQyxxQkFBa0IsbUJBQUMsQUFBZ0IsQUFBQyxvQkFDM0MsbUJBQUEsWUFBTSxPQUFDLHFCQUFrQixtQkFBQyxBQUFRLEFBQUMsa0ZBZi9CLEFBQWlDLEFBdUY3QztBQXZGWSw0Q0FBaUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBpbmplY3RhYmxlLCBpbmplY3QgfSBmcm9tICdpbnZlcnNpZnknO1xuaW1wb3J0IHsgU2VydmljZUlkZW50aWZpZXJzIH0gZnJvbSAnLi4vLi4vLi4vY29udGFpbmVyL1NlcnZpY2VJZGVudGlmaWVycyc7XG5cbmltcG9ydCAqIGFzIEVTVHJlZSBmcm9tICdlc3RyZWUnO1xuXG5pbXBvcnQgeyBUQ29udHJvbEZsb3dDdXN0b21Ob2RlRmFjdG9yeSB9IGZyb20gJy4uLy4uLy4uL3R5cGVzL2NvbnRhaW5lci9jdXN0b20tbm9kZXMvVENvbnRyb2xGbG93Q3VzdG9tTm9kZUZhY3RvcnknO1xuaW1wb3J0IHsgVFN0YXRlbWVudCB9IGZyb20gJy4uLy4uLy4uL3R5cGVzL25vZGUvVFN0YXRlbWVudCc7XG5cbmltcG9ydCB7IElDdXN0b21Ob2RlIH0gZnJvbSAnLi4vLi4vLi4vaW50ZXJmYWNlcy9jdXN0b20tbm9kZXMvSUN1c3RvbU5vZGUnO1xuaW1wb3J0IHsgSU9wdGlvbnMgfSBmcm9tICcuLi8uLi8uLi9pbnRlcmZhY2VzL29wdGlvbnMvSU9wdGlvbnMnO1xuaW1wb3J0IHsgSVJhbmRvbUdlbmVyYXRvciB9IGZyb20gJy4uLy4uLy4uL2ludGVyZmFjZXMvdXRpbHMvSVJhbmRvbUdlbmVyYXRvcic7XG5pbXBvcnQgeyBJU3RvcmFnZSB9IGZyb20gJy4uLy4uLy4uL2ludGVyZmFjZXMvc3RvcmFnZXMvSVN0b3JhZ2UnO1xuXG5pbXBvcnQgeyBDb250cm9sRmxvd0N1c3RvbU5vZGUgfSBmcm9tICcuLi8uLi8uLi9lbnVtcy9jb250YWluZXIvY3VzdG9tLW5vZGVzL0NvbnRyb2xGbG93Q3VzdG9tTm9kZSc7XG5cbmltcG9ydCB7IEFic3RyYWN0Q29udHJvbEZsb3dSZXBsYWNlciB9IGZyb20gJy4vQWJzdHJhY3RDb250cm9sRmxvd1JlcGxhY2VyJztcbmltcG9ydCB7IE5vZGUgfSBmcm9tICcuLi8uLi8uLi9ub2RlL05vZGUnO1xuXG5AaW5qZWN0YWJsZSgpXG5leHBvcnQgY2xhc3MgQ2FsbEV4cHJlc3Npb25Db250cm9sRmxvd1JlcGxhY2VyIGV4dGVuZHMgQWJzdHJhY3RDb250cm9sRmxvd1JlcGxhY2VyIHtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHByaXZhdGUgc3RhdGljIHJlYWRvbmx5IHVzaW5nRXhpc3RpbmdJZGVudGlmaWVyQ2hhbmNlOiBudW1iZXIgPSAwLjU7XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1RDb250cm9sRmxvd0N1c3RvbU5vZGVGYWN0b3J5fSBjb250cm9sRmxvd0N1c3RvbU5vZGVGYWN0b3J5XG4gICAgICogQHBhcmFtIHtJUmFuZG9tR2VuZXJhdG9yfSByYW5kb21HZW5lcmF0b3JcbiAgICAgKiBAcGFyYW0ge0lPcHRpb25zfSBvcHRpb25zXG4gICAgICovXG4gICAgY29uc3RydWN0b3IgKFxuICAgICAgICBAaW5qZWN0KFNlcnZpY2VJZGVudGlmaWVycy5GYWN0b3J5X19JQ29udHJvbEZsb3dDdXN0b21Ob2RlKVxuICAgICAgICAgICAgY29udHJvbEZsb3dDdXN0b21Ob2RlRmFjdG9yeTogVENvbnRyb2xGbG93Q3VzdG9tTm9kZUZhY3RvcnksXG4gICAgICAgIEBpbmplY3QoU2VydmljZUlkZW50aWZpZXJzLklSYW5kb21HZW5lcmF0b3IpIHJhbmRvbUdlbmVyYXRvcjogSVJhbmRvbUdlbmVyYXRvcixcbiAgICAgICAgQGluamVjdChTZXJ2aWNlSWRlbnRpZmllcnMuSU9wdGlvbnMpIG9wdGlvbnM6IElPcHRpb25zXG4gICAgKSB7XG4gICAgICAgIHN1cGVyKGNvbnRyb2xGbG93Q3VzdG9tTm9kZUZhY3RvcnksIHJhbmRvbUdlbmVyYXRvciwgb3B0aW9ucyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtDYWxsRXhwcmVzc2lvbn0gY2FsbEV4cHJlc3Npb25Ob2RlXG4gICAgICogQHBhcmFtIHtOb2RlfSBwYXJlbnROb2RlXG4gICAgICogQHBhcmFtIHtJU3RvcmFnZTxJQ3VzdG9tTm9kZT59IGNvbnRyb2xGbG93U3RvcmFnZVxuICAgICAqIEByZXR1cm5zIHtOb2RlfVxuICAgICAqL1xuICAgIHB1YmxpYyByZXBsYWNlIChcbiAgICAgICAgY2FsbEV4cHJlc3Npb25Ob2RlOiBFU1RyZWUuQ2FsbEV4cHJlc3Npb24sXG4gICAgICAgIHBhcmVudE5vZGU6IEVTVHJlZS5Ob2RlLFxuICAgICAgICBjb250cm9sRmxvd1N0b3JhZ2U6IElTdG9yYWdlIDxJQ3VzdG9tTm9kZT5cbiAgICApOiBFU1RyZWUuTm9kZSB7XG4gICAgICAgIGNvbnN0IGNhbGxlZTogRVNUcmVlLkV4cHJlc3Npb24gPSA8RVNUcmVlLkV4cHJlc3Npb24+Y2FsbEV4cHJlc3Npb25Ob2RlLmNhbGxlZTtcblxuICAgICAgICBpZiAoIU5vZGUuaXNJZGVudGlmaWVyTm9kZShjYWxsZWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gY2FsbEV4cHJlc3Npb25Ob2RlO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgcmVwbGFjZXJJZDogc3RyaW5nID0gU3RyaW5nKGNhbGxFeHByZXNzaW9uTm9kZS5hcmd1bWVudHMubGVuZ3RoKTtcbiAgICAgICAgY29uc3QgY2FsbEV4cHJlc3Npb25GdW5jdGlvbkN1c3RvbU5vZGU6IElDdXN0b21Ob2RlID0gdGhpcy5jb250cm9sRmxvd0N1c3RvbU5vZGVGYWN0b3J5KFxuICAgICAgICAgICAgQ29udHJvbEZsb3dDdXN0b21Ob2RlLkNhbGxFeHByZXNzaW9uRnVuY3Rpb25Ob2RlXG4gICAgICAgICk7XG4gICAgICAgIGNvbnN0IGV4cHJlc3Npb25Bcmd1bWVudHM6IChFU1RyZWUuRXhwcmVzc2lvbiB8IEVTVHJlZS5TcHJlYWRFbGVtZW50KVtdID0gY2FsbEV4cHJlc3Npb25Ob2RlLmFyZ3VtZW50cztcblxuICAgICAgICBjYWxsRXhwcmVzc2lvbkZ1bmN0aW9uQ3VzdG9tTm9kZS5pbml0aWFsaXplKGV4cHJlc3Npb25Bcmd1bWVudHMpO1xuXG4gICAgICAgIGNvbnN0IHN0b3JhZ2VLZXk6IHN0cmluZyA9IHRoaXMuaW5zZXJ0Q3VzdG9tTm9kZVRvQ29udHJvbEZsb3dTdG9yYWdlKFxuICAgICAgICAgICAgY2FsbEV4cHJlc3Npb25GdW5jdGlvbkN1c3RvbU5vZGUsXG4gICAgICAgICAgICBjb250cm9sRmxvd1N0b3JhZ2UsXG4gICAgICAgICAgICByZXBsYWNlcklkLFxuICAgICAgICAgICAgQ2FsbEV4cHJlc3Npb25Db250cm9sRmxvd1JlcGxhY2VyLnVzaW5nRXhpc3RpbmdJZGVudGlmaWVyQ2hhbmNlXG4gICAgICAgICk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Q29udHJvbEZsb3dTdG9yYWdlQ2FsbE5vZGUoXG4gICAgICAgICAgICBjb250cm9sRmxvd1N0b3JhZ2UuZ2V0U3RvcmFnZUlkKCksXG4gICAgICAgICAgICBzdG9yYWdlS2V5LFxuICAgICAgICAgICAgY2FsbGVlLFxuICAgICAgICAgICAgZXhwcmVzc2lvbkFyZ3VtZW50c1xuICAgICAgICApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjb250cm9sRmxvd1N0b3JhZ2VJZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzdG9yYWdlS2V5XG4gICAgICogQHBhcmFtIHtFeHByZXNzaW9ufSBjYWxsZWVcbiAgICAgKiBAcGFyYW0geyhFeHByZXNzaW9uIHwgU3ByZWFkRWxlbWVudClbXX0gZXhwcmVzc2lvbkFyZ3VtZW50c1xuICAgICAqIEByZXR1cm5zIHtOb2RlfVxuICAgICAqL1xuICAgIHByb3RlY3RlZCBnZXRDb250cm9sRmxvd1N0b3JhZ2VDYWxsTm9kZSAoXG4gICAgICAgIGNvbnRyb2xGbG93U3RvcmFnZUlkOiBzdHJpbmcsXG4gICAgICAgIHN0b3JhZ2VLZXk6IHN0cmluZyxcbiAgICAgICAgY2FsbGVlOiBFU1RyZWUuRXhwcmVzc2lvbixcbiAgICAgICAgZXhwcmVzc2lvbkFyZ3VtZW50czogKEVTVHJlZS5FeHByZXNzaW9uIHwgRVNUcmVlLlNwcmVhZEVsZW1lbnQpW11cbiAgICApOiBFU1RyZWUuTm9kZSB7XG4gICAgICAgIGNvbnN0IGNvbnRyb2xGbG93U3RvcmFnZUNhbGxDdXN0b21Ob2RlOiBJQ3VzdG9tTm9kZSA9IHRoaXMuY29udHJvbEZsb3dDdXN0b21Ob2RlRmFjdG9yeShcbiAgICAgICAgICAgIENvbnRyb2xGbG93Q3VzdG9tTm9kZS5DYWxsRXhwcmVzc2lvbkNvbnRyb2xGbG93U3RvcmFnZUNhbGxOb2RlXG4gICAgICAgICk7XG5cbiAgICAgICAgY29udHJvbEZsb3dTdG9yYWdlQ2FsbEN1c3RvbU5vZGUuaW5pdGlhbGl6ZShjb250cm9sRmxvd1N0b3JhZ2VJZCwgc3RvcmFnZUtleSwgY2FsbGVlLCBleHByZXNzaW9uQXJndW1lbnRzKTtcblxuICAgICAgICBjb25zdCBzdGF0ZW1lbnROb2RlOiBUU3RhdGVtZW50ID0gY29udHJvbEZsb3dTdG9yYWdlQ2FsbEN1c3RvbU5vZGUuZ2V0Tm9kZSgpWzBdO1xuXG4gICAgICAgIGlmICghc3RhdGVtZW50Tm9kZSB8fCAhTm9kZS5pc0V4cHJlc3Npb25TdGF0ZW1lbnROb2RlKHN0YXRlbWVudE5vZGUpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFxcYGNvbnRyb2xGbG93U3RvcmFnZUNhbGxDdXN0b21Ob2RlLmdldE5vZGUoKVswXVxcYCBzaG91bGQgcmV0dXJucyBhcnJheSB3aXRoIFxcYEV4cHJlc3Npb25TdGF0ZW1lbnRcXGAgbm9kZWApO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHN0YXRlbWVudE5vZGUuZXhwcmVzc2lvbjtcbiAgICB9XG59XG4iXX0=