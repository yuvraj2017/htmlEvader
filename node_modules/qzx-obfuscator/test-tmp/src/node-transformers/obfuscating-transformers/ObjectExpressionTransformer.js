"use strict";

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var inversify_1 = require("inversify");
var ServiceIdentifiers_1 = require("../../container/ServiceIdentifiers");
var NodeType_1 = require("../../enums/NodeType");
var AbstractNodeTransformer_1 = require("../AbstractNodeTransformer");
var Node_1 = require("../../node/Node");
var ObjectExpressionTransformer = ObjectExpressionTransformer_1 = function (_AbstractNodeTransfor) {
    _inherits(ObjectExpressionTransformer, _AbstractNodeTransfor);

    function ObjectExpressionTransformer(randomGenerator, options) {
        _classCallCheck(this, ObjectExpressionTransformer);

        return _possibleConstructorReturn(this, (ObjectExpressionTransformer.__proto__ || Object.getPrototypeOf(ObjectExpressionTransformer)).call(this, randomGenerator, options));
    }

    _createClass(ObjectExpressionTransformer, [{
        key: "getVisitor",
        value: function getVisitor() {
            var _this2 = this;

            return {
                enter: function enter(node, parentNode) {
                    if (Node_1.Node.isObjectExpressionNode(node)) {
                        return _this2.transformNode(node, parentNode);
                    }
                }
            };
        }
    }, {
        key: "transformNode",
        value: function transformNode(objectExpressionNode, parentNode) {
            objectExpressionNode.properties.forEach(function (property) {
                if (property.shorthand) {
                    property.shorthand = false;
                }
                if (Node_1.Node.isIdentifierNode(property.key)) {
                    property.key = ObjectExpressionTransformer_1.transformIdentifierPropertyKey(property.key);
                }
            });
            return objectExpressionNode;
        }
    }], [{
        key: "transformIdentifierPropertyKey",
        value: function transformIdentifierPropertyKey(node) {
            return {
                type: NodeType_1.NodeType.Literal,
                value: node.name,
                raw: "'" + node.name + "'"
            };
        }
    }]);

    return ObjectExpressionTransformer;
}(AbstractNodeTransformer_1.AbstractNodeTransformer);
ObjectExpressionTransformer = ObjectExpressionTransformer_1 = tslib_1.__decorate([inversify_1.injectable(), tslib_1.__param(0, inversify_1.inject(ServiceIdentifiers_1.ServiceIdentifiers.IRandomGenerator)), tslib_1.__param(1, inversify_1.inject(ServiceIdentifiers_1.ServiceIdentifiers.IOptions)), tslib_1.__metadata("design:paramtypes", [Object, Object])], ObjectExpressionTransformer);
exports.ObjectExpressionTransformer = ObjectExpressionTransformer;
var ObjectExpressionTransformer_1;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiT2JqZWN0RXhwcmVzc2lvblRyYW5zZm9ybWVyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vc3JjL25vZGUtdHJhbnNmb3JtZXJzL29iZnVzY2F0aW5nLXRyYW5zZm9ybWVycy9PYmplY3RFeHByZXNzaW9uVHJhbnNmb3JtZXIudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQUEsMEJBQStDO0FBQy9DLG1DQUF3RTtBQVF4RSx5QkFBZ0Q7QUFFaEQsd0NBQXFFO0FBQ3JFLHFCQUF1QztBQVV2QyxJQUFhLEFBQTJCO0FBQXhDLEFBQXlDOztBQUtyQyx5Q0FDaUQsQUFBaUMsaUJBQ3pDLEFBQWlCO0FBRXRELEFBQUs7O3lKQUFDLEFBQWUsaUJBQUUsQUFBTyxBQUFDLEFBQUMsQUFDcEM7QUFBQyxBQU1PLEFBQU0sQUFBQyxBQUE4Qjs7Ozs7OztBQVl6QyxBQUFNO0FBQ0YsQUFBSyx1QkFBRSxlQUFDLEFBQWlCLE1BQUUsQUFBdUI7QUFDOUMsQUFBRSxBQUFDLHdCQUFDLE9BQUksS0FBQyxBQUFzQix1QkFBQyxBQUFJLEFBQUMsQUFBQyxPQUFDLEFBQUM7QUFDcEMsQUFBTSwrQkFBQyxBQUFJLE9BQUMsQUFBYSxjQUFDLEFBQUksTUFBRSxBQUFVLEFBQUMsQUFBQyxBQUNoRDtBQUFDLEFBQ0w7QUFBQyxBQUNKLEFBQUMsQUFDTjtBQVBXO0FBT1YsQUFPTSxBQUFhOzs7c0NBQUUsQUFBNkMsc0JBQUUsQUFBdUI7QUFDeEYsQUFBb0IsaUNBQUMsQUFBVSxXQUMxQixBQUFPLFFBQUMsVUFBQyxBQUF5QjtBQUMvQixBQUFFLEFBQUMsb0JBQUMsQUFBUSxTQUFDLEFBQVMsQUFBQyxXQUFDLEFBQUM7QUFDckIsQUFBUSw2QkFBQyxBQUFTLFlBQUcsQUFBSyxBQUFDLEFBQy9CO0FBQUM7QUFFRCxBQUFFLEFBQUMsb0JBQUMsT0FBSSxLQUFDLEFBQWdCLGlCQUFDLEFBQVEsU0FBQyxBQUFHLEFBQUMsQUFBQyxNQUFDLEFBQUM7QUFDdEMsQUFBUSw2QkFBQyxBQUFHLE1BQUcsQUFBMkIsOEJBQUMsQUFBOEIsK0JBQUMsQUFBUSxTQUFDLEFBQUcsQUFBQyxBQUFDLEFBQzVGO0FBQUMsQUFDTDtBQUFDLEFBQUMsQUFBQztBQUVQLEFBQU0sbUJBQUMsQUFBb0IsQUFBQyxBQUNoQztBQUFDLEFBQ0o7Ozt1REF4Q2tELEFBQXVCO0FBQ2xFLEFBQU07QUFDRixBQUFJLHNCQUFFLFdBQVEsU0FBQyxBQUFPO0FBQ3RCLEFBQUssdUJBQUUsQUFBSSxLQUFDLEFBQUk7QUFDaEIsQUFBRyxBQUFFLDJCQUFJLEFBQUksS0FBQyxBQUFJLEFBQUcsQUFDeEIsQUFBQyxBQUNOO0FBTFc7QUFLVixBQUtNLEFBQVU7Ozs7RUEzQjRCLDBCQUF1QjtBQUEzRCxBQUEyQixrRkFEdkMsWUFBVSxBQUFFLGNBT0osbUJBQUEsWUFBTSxPQUFDLHFCQUFrQixtQkFBQyxBQUFnQixBQUFDLG9CQUMzQyxtQkFBQSxZQUFNLE9BQUMscUJBQWtCLG1CQUFDLEFBQVEsQUFBQyx3RUFQL0IsQUFBMkIsQUF3RHZDO0FBeERZLHNDQUEyQiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGluamVjdGFibGUsIGluamVjdCB9IGZyb20gJ2ludmVyc2lmeSc7XG5pbXBvcnQgeyBTZXJ2aWNlSWRlbnRpZmllcnMgfSBmcm9tICcuLi8uLi9jb250YWluZXIvU2VydmljZUlkZW50aWZpZXJzJztcblxuaW1wb3J0ICogYXMgRVNUcmVlIGZyb20gJ2VzdHJlZSc7XG5cbmltcG9ydCB7IElPcHRpb25zIH0gZnJvbSAnLi4vLi4vaW50ZXJmYWNlcy9vcHRpb25zL0lPcHRpb25zJztcbmltcG9ydCB7IElSYW5kb21HZW5lcmF0b3IgfSBmcm9tICcuLi8uLi9pbnRlcmZhY2VzL3V0aWxzL0lSYW5kb21HZW5lcmF0b3InO1xuaW1wb3J0IHsgSVZpc2l0b3IgfSBmcm9tICcuLi8uLi9pbnRlcmZhY2VzL0lWaXNpdG9yJztcblxuaW1wb3J0IHsgTm9kZVR5cGUgfSBmcm9tICcuLi8uLi9lbnVtcy9Ob2RlVHlwZSc7XG5cbmltcG9ydCB7IEFic3RyYWN0Tm9kZVRyYW5zZm9ybWVyIH0gZnJvbSAnLi4vQWJzdHJhY3ROb2RlVHJhbnNmb3JtZXInO1xuaW1wb3J0IHsgTm9kZSB9IGZyb20gJy4uLy4uL25vZGUvTm9kZSc7XG5cbi8qKlxuICogcmVwbGFjZXM6XG4gKiAgICAgdmFyIG9iamVjdCA9IHsgUFNFVURPOiAxIH07XG4gKlxuICogb246XG4gKiAgICAgdmFyIG9iamVjdCA9IHsgJ1BTRVVETyc6IDEgfTtcbiAqL1xuQGluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIE9iamVjdEV4cHJlc3Npb25UcmFuc2Zvcm1lciBleHRlbmRzIEFic3RyYWN0Tm9kZVRyYW5zZm9ybWVyIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0lSYW5kb21HZW5lcmF0b3J9IHJhbmRvbUdlbmVyYXRvclxuICAgICAqIEBwYXJhbSB7SU9wdGlvbnN9IG9wdGlvbnNcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvciAoXG4gICAgICAgIEBpbmplY3QoU2VydmljZUlkZW50aWZpZXJzLklSYW5kb21HZW5lcmF0b3IpIHJhbmRvbUdlbmVyYXRvcjogSVJhbmRvbUdlbmVyYXRvcixcbiAgICAgICAgQGluamVjdChTZXJ2aWNlSWRlbnRpZmllcnMuSU9wdGlvbnMpIG9wdGlvbnM6IElPcHRpb25zXG4gICAgKSB7XG4gICAgICAgIHN1cGVyKHJhbmRvbUdlbmVyYXRvciwgb3B0aW9ucyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtJZGVudGlmaWVyfSBub2RlXG4gICAgICogQHJldHVybnMge0xpdGVyYWx9XG4gICAgICovXG4gICAgcHJpdmF0ZSBzdGF0aWMgdHJhbnNmb3JtSWRlbnRpZmllclByb3BlcnR5S2V5IChub2RlOiBFU1RyZWUuSWRlbnRpZmllcik6IEVTVHJlZS5MaXRlcmFsIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6IE5vZGVUeXBlLkxpdGVyYWwsXG4gICAgICAgICAgICB2YWx1ZTogbm9kZS5uYW1lLFxuICAgICAgICAgICAgcmF3OiBgJyR7bm9kZS5uYW1lfSdgXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybiB7SVZpc2l0b3J9XG4gICAgICovXG4gICAgcHVibGljIGdldFZpc2l0b3IgKCk6IElWaXNpdG9yIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGVudGVyOiAobm9kZTogRVNUcmVlLk5vZGUsIHBhcmVudE5vZGU6IEVTVHJlZS5Ob2RlKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKE5vZGUuaXNPYmplY3RFeHByZXNzaW9uTm9kZShub2RlKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm1Ob2RlKG5vZGUsIHBhcmVudE5vZGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdEV4cHJlc3Npb259IG9iamVjdEV4cHJlc3Npb25Ob2RlXG4gICAgICogQHBhcmFtIHtOb2RlfSBwYXJlbnROb2RlXG4gICAgICogQHJldHVybnMge05vZGV9XG4gICAgICovXG4gICAgcHVibGljIHRyYW5zZm9ybU5vZGUgKG9iamVjdEV4cHJlc3Npb25Ob2RlOiBFU1RyZWUuT2JqZWN0RXhwcmVzc2lvbiwgcGFyZW50Tm9kZTogRVNUcmVlLk5vZGUpOiBFU1RyZWUuTm9kZSB7XG4gICAgICAgIG9iamVjdEV4cHJlc3Npb25Ob2RlLnByb3BlcnRpZXNcbiAgICAgICAgICAgIC5mb3JFYWNoKChwcm9wZXJ0eTogRVNUcmVlLlByb3BlcnR5KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHByb3BlcnR5LnNob3J0aGFuZCkge1xuICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0eS5zaG9ydGhhbmQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoTm9kZS5pc0lkZW50aWZpZXJOb2RlKHByb3BlcnR5LmtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJvcGVydHkua2V5ID0gT2JqZWN0RXhwcmVzc2lvblRyYW5zZm9ybWVyLnRyYW5zZm9ybUlkZW50aWZpZXJQcm9wZXJ0eUtleShwcm9wZXJ0eS5rZXkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBvYmplY3RFeHByZXNzaW9uTm9kZTtcbiAgICB9XG59XG4iXX0=