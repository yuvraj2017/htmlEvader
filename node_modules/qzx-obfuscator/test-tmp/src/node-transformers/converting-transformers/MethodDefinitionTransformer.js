"use strict";

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var inversify_1 = require("inversify");
var ServiceIdentifiers_1 = require("../../container/ServiceIdentifiers");
var NodeType_1 = require("../../enums/NodeType");
var AbstractNodeTransformer_1 = require("../AbstractNodeTransformer");
var Node_1 = require("../../node/Node");
var MethodDefinitionTransformer = MethodDefinitionTransformer_1 = function (_AbstractNodeTransfor) {
    _inherits(MethodDefinitionTransformer, _AbstractNodeTransfor);

    function MethodDefinitionTransformer(randomGenerator, options) {
        _classCallCheck(this, MethodDefinitionTransformer);

        return _possibleConstructorReturn(this, (MethodDefinitionTransformer.__proto__ || Object.getPrototypeOf(MethodDefinitionTransformer)).call(this, randomGenerator, options));
    }

    _createClass(MethodDefinitionTransformer, [{
        key: "getVisitor",
        value: function getVisitor() {
            var _this2 = this;

            return {
                enter: function enter(node, parentNode) {
                    if (Node_1.Node.isMethodDefinitionNode(node)) {
                        return _this2.transformNode(node, parentNode);
                    }
                }
            };
        }
    }, {
        key: "transformNode",
        value: function transformNode(methodDefinitionNode, parentNode) {
            if (Node_1.Node.isIdentifierNode(methodDefinitionNode.key) && !(MethodDefinitionTransformer_1.ignoredNames.indexOf(methodDefinitionNode.key.name) !== -1) && methodDefinitionNode.computed === false) {
                methodDefinitionNode.computed = true;
                methodDefinitionNode.key = {
                    type: NodeType_1.NodeType.Literal,
                    value: methodDefinitionNode.key.name,
                    raw: "'" + methodDefinitionNode.key.name + "'"
                };
            }
            return methodDefinitionNode;
        }
    }]);

    return MethodDefinitionTransformer;
}(AbstractNodeTransformer_1.AbstractNodeTransformer);
MethodDefinitionTransformer.ignoredNames = ['constructor'];
MethodDefinitionTransformer = MethodDefinitionTransformer_1 = tslib_1.__decorate([inversify_1.injectable(), tslib_1.__param(0, inversify_1.inject(ServiceIdentifiers_1.ServiceIdentifiers.IRandomGenerator)), tslib_1.__param(1, inversify_1.inject(ServiceIdentifiers_1.ServiceIdentifiers.IOptions)), tslib_1.__metadata("design:paramtypes", [Object, Object])], MethodDefinitionTransformer);
exports.MethodDefinitionTransformer = MethodDefinitionTransformer;
var MethodDefinitionTransformer_1;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiTWV0aG9kRGVmaW5pdGlvblRyYW5zZm9ybWVyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vc3JjL25vZGUtdHJhbnNmb3JtZXJzL2NvbnZlcnRpbmctdHJhbnNmb3JtZXJzL01ldGhvZERlZmluaXRpb25UcmFuc2Zvcm1lci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFBQSwwQkFBK0M7QUFDL0MsbUNBQXdFO0FBUXhFLHlCQUFnRDtBQUVoRCx3Q0FBcUU7QUFDckUscUJBQXVDO0FBWXZDLElBQWEsQUFBMkI7QUFBeEMsQUFBeUM7O0FBVXJDLHlDQUNpRCxBQUFpQyxpQkFDekMsQUFBaUI7QUFFdEQsQUFBSzs7eUpBQUMsQUFBZSxpQkFBRSxBQUFPLEFBQUMsQUFBQyxBQUNwQztBQUFDLEFBS00sQUFBVTs7Ozs7OztBQUNiLEFBQU07QUFDRixBQUFLLHVCQUFFLGVBQUMsQUFBaUIsTUFBRSxBQUF1QjtBQUM5QyxBQUFFLEFBQUMsd0JBQUMsT0FBSSxLQUFDLEFBQXNCLHVCQUFDLEFBQUksQUFBQyxBQUFDLE9BQUMsQUFBQztBQUNwQyxBQUFNLCtCQUFDLEFBQUksT0FBQyxBQUFhLGNBQUMsQUFBSSxNQUFFLEFBQVUsQUFBQyxBQUFDLEFBQ2hEO0FBQUMsQUFDTDtBQUFDLEFBQ0osQUFBQyxBQUNOO0FBUFc7QUFPVixBQWlCTSxBQUFhOzs7c0NBQUUsQUFBNkMsc0JBQUUsQUFBdUI7QUFDeEYsQUFBRSxBQUFDLGdCQUNDLE9BQUksS0FBQyxBQUFnQixpQkFBQyxBQUFvQixxQkFBQyxBQUFHLEFBQUMsUUFDL0MsRUFBQyxBQUEyQiw4QkFBQyxBQUFZLGFBQUMsQUFBUSxRQUFDLEFBQW9CLHFCQUFDLEFBQUcsSUFBQyxBQUFJLEFBQUMsaUJBQ2pGLEFBQW9CLHFCQUFDLEFBQVEsYUFBSyxBQUN0QyxBQUFDLE9BQUMsQUFBQztBQUNDLEFBQW9CLHFDQUFDLEFBQVEsV0FBRyxBQUFJLEFBQUM7QUFDckMsQUFBb0IscUNBQUMsQUFBRztBQUNwQixBQUFJLDBCQUFFLFdBQVEsU0FBQyxBQUFPO0FBQ3RCLEFBQUssMkJBQUUsQUFBb0IscUJBQUMsQUFBRyxJQUFDLEFBQUk7QUFDcEMsQUFBRyxBQUFFLCtCQUFJLEFBQW9CLHFCQUFDLEFBQUcsSUFBQyxBQUFJLEFBQUcsQUFDNUMsQUFBQyxBQUNOO0FBTCtCO0FBSzlCO0FBRUQsQUFBTSxtQkFBQyxBQUFvQixBQUFDLEFBQ2hDO0FBQUMsQUFDSjs7OztFQTdEZ0QsMEJBQXVCO0FBSTVDLDRCQUFZLGVBQWEsQ0FBQyxBQUFhLEFBQUMsQUFBQztBQUp4RCxBQUEyQixrRkFEdkMsWUFBVSxBQUFFLGNBWUosbUJBQUEsWUFBTSxPQUFDLHFCQUFrQixtQkFBQyxBQUFnQixBQUFDLG9CQUMzQyxtQkFBQSxZQUFNLE9BQUMscUJBQWtCLG1CQUFDLEFBQVEsQUFBQyx3RUFaL0IsQUFBMkIsQUE2RHZDO0FBN0RZLHNDQUEyQiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGluamVjdGFibGUsIGluamVjdCB9IGZyb20gJ2ludmVyc2lmeSc7XG5pbXBvcnQgeyBTZXJ2aWNlSWRlbnRpZmllcnMgfSBmcm9tICcuLi8uLi9jb250YWluZXIvU2VydmljZUlkZW50aWZpZXJzJztcblxuaW1wb3J0ICogYXMgRVNUcmVlIGZyb20gJ2VzdHJlZSc7XG5cbmltcG9ydCB7IElPcHRpb25zIH0gZnJvbSAnLi4vLi4vaW50ZXJmYWNlcy9vcHRpb25zL0lPcHRpb25zJztcbmltcG9ydCB7IElSYW5kb21HZW5lcmF0b3IgfSBmcm9tICcuLi8uLi9pbnRlcmZhY2VzL3V0aWxzL0lSYW5kb21HZW5lcmF0b3InO1xuaW1wb3J0IHsgSVZpc2l0b3IgfSBmcm9tICcuLi8uLi9pbnRlcmZhY2VzL0lWaXNpdG9yJztcblxuaW1wb3J0IHsgTm9kZVR5cGUgfSBmcm9tICcuLi8uLi9lbnVtcy9Ob2RlVHlwZSc7XG5cbmltcG9ydCB7IEFic3RyYWN0Tm9kZVRyYW5zZm9ybWVyIH0gZnJvbSAnLi4vQWJzdHJhY3ROb2RlVHJhbnNmb3JtZXInO1xuaW1wb3J0IHsgTm9kZSB9IGZyb20gJy4uLy4uL25vZGUvTm9kZSc7XG5cbi8qKlxuICogcmVwbGFjZXM6XG4gKiAgICAgZm9vICgpIHsgLy8uLi4gfTtcbiAqXG4gKiBvbjpcbiAqICAgICBbJ2ZvbyddIHsgLy8uLi4gfTtcbiAqXG4gKiBMaXRlcmFsIG5vZGUgd2lsbCBiZSBvYmZ1c2NhdGVkIGJ5IExpdGVyYWxUcmFuc2Zvcm1lclxuICovXG5AaW5qZWN0YWJsZSgpXG5leHBvcnQgY2xhc3MgTWV0aG9kRGVmaW5pdGlvblRyYW5zZm9ybWVyIGV4dGVuZHMgQWJzdHJhY3ROb2RlVHJhbnNmb3JtZXIge1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtzdHJpbmdbXX1cbiAgICAgKi9cbiAgICBwcml2YXRlIHN0YXRpYyByZWFkb25seSBpZ25vcmVkTmFtZXM6IHN0cmluZ1tdID0gWydjb25zdHJ1Y3RvciddO1xuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtJUmFuZG9tR2VuZXJhdG9yfSByYW5kb21HZW5lcmF0b3JcbiAgICAgKiBAcGFyYW0ge0lPcHRpb25zfSBvcHRpb25zXG4gICAgICovXG4gICAgY29uc3RydWN0b3IgKFxuICAgICAgICBAaW5qZWN0KFNlcnZpY2VJZGVudGlmaWVycy5JUmFuZG9tR2VuZXJhdG9yKSByYW5kb21HZW5lcmF0b3I6IElSYW5kb21HZW5lcmF0b3IsXG4gICAgICAgIEBpbmplY3QoU2VydmljZUlkZW50aWZpZXJzLklPcHRpb25zKSBvcHRpb25zOiBJT3B0aW9uc1xuICAgICkge1xuICAgICAgICBzdXBlcihyYW5kb21HZW5lcmF0b3IsIG9wdGlvbnMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm4ge0lWaXNpdG9yfVxuICAgICAqL1xuICAgIHB1YmxpYyBnZXRWaXNpdG9yICgpOiBJVmlzaXRvciB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBlbnRlcjogKG5vZGU6IEVTVHJlZS5Ob2RlLCBwYXJlbnROb2RlOiBFU1RyZWUuTm9kZSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChOb2RlLmlzTWV0aG9kRGVmaW5pdGlvbk5vZGUobm9kZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtTm9kZShub2RlLCBwYXJlbnROb2RlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogcmVwbGFjZXM6XG4gICAgICogICAgIG9iamVjdC5pZGVudGlmaWVyID0gMTtcbiAgICAgKlxuICAgICAqIG9uOlxuICAgICAqICAgICBvYmplY3RbJ2lkZW50aWZpZXInXSA9IDE7XG4gICAgICpcbiAgICAgKiBhbmQgc2tpcDpcbiAgICAgKiAgICAgb2JqZWN0W2lkZW50aWZpZXJdID0gMTtcbiAgICAgKiBMaXRlcmFsIG5vZGUgd2lsbCBiZSBvYmZ1c2NhdGVkIGJ5IExpdGVyYWxUcmFuc2Zvcm1lclxuICAgICAqXG4gICAgICogQHBhcmFtIHtNZXRob2REZWZpbml0aW9ufSBtZXRob2REZWZpbml0aW9uTm9kZVxuICAgICAqIEBwYXJhbSB7Tm9kZX0gcGFyZW50Tm9kZVxuICAgICAqIEByZXR1cm5zIHtOb2RlfVxuICAgICAqL1xuICAgIHB1YmxpYyB0cmFuc2Zvcm1Ob2RlIChtZXRob2REZWZpbml0aW9uTm9kZTogRVNUcmVlLk1ldGhvZERlZmluaXRpb24sIHBhcmVudE5vZGU6IEVTVHJlZS5Ob2RlKTogRVNUcmVlLk5vZGUge1xuICAgICAgICBpZiAoXG4gICAgICAgICAgICBOb2RlLmlzSWRlbnRpZmllck5vZGUobWV0aG9kRGVmaW5pdGlvbk5vZGUua2V5KSAmJlxuICAgICAgICAgICAgIU1ldGhvZERlZmluaXRpb25UcmFuc2Zvcm1lci5pZ25vcmVkTmFtZXMuaW5jbHVkZXMobWV0aG9kRGVmaW5pdGlvbk5vZGUua2V5Lm5hbWUpICYmXG4gICAgICAgICAgICBtZXRob2REZWZpbml0aW9uTm9kZS5jb21wdXRlZCA9PT0gZmFsc2VcbiAgICAgICAgKSB7XG4gICAgICAgICAgICBtZXRob2REZWZpbml0aW9uTm9kZS5jb21wdXRlZCA9IHRydWU7XG4gICAgICAgICAgICBtZXRob2REZWZpbml0aW9uTm9kZS5rZXkgPSB7XG4gICAgICAgICAgICAgICAgdHlwZTogTm9kZVR5cGUuTGl0ZXJhbCxcbiAgICAgICAgICAgICAgICB2YWx1ZTogbWV0aG9kRGVmaW5pdGlvbk5vZGUua2V5Lm5hbWUsXG4gICAgICAgICAgICAgICAgcmF3OiBgJyR7bWV0aG9kRGVmaW5pdGlvbk5vZGUua2V5Lm5hbWV9J2BcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbWV0aG9kRGVmaW5pdGlvbk5vZGU7XG4gICAgfVxufVxuIl19