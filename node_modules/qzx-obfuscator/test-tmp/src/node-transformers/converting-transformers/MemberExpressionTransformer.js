"use strict";

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var inversify_1 = require("inversify");
var ServiceIdentifiers_1 = require("../../container/ServiceIdentifiers");
var NodeType_1 = require("../../enums/NodeType");
var AbstractNodeTransformer_1 = require("../AbstractNodeTransformer");
var Node_1 = require("../../node/Node");
var MemberExpressionTransformer = function (_AbstractNodeTransfor) {
    _inherits(MemberExpressionTransformer, _AbstractNodeTransfor);

    function MemberExpressionTransformer(randomGenerator, options) {
        _classCallCheck(this, MemberExpressionTransformer);

        return _possibleConstructorReturn(this, (MemberExpressionTransformer.__proto__ || Object.getPrototypeOf(MemberExpressionTransformer)).call(this, randomGenerator, options));
    }

    _createClass(MemberExpressionTransformer, [{
        key: "getVisitor",
        value: function getVisitor() {
            var _this2 = this;

            return {
                enter: function enter(node, parentNode) {
                    if (Node_1.Node.isMemberExpressionNode(node)) {
                        return _this2.transformNode(node, parentNode);
                    }
                }
            };
        }
    }, {
        key: "transformNode",
        value: function transformNode(memberExpressionNode, parentNode) {
            if (Node_1.Node.isIdentifierNode(memberExpressionNode.property)) {
                if (memberExpressionNode.computed) {
                    return memberExpressionNode;
                }
                memberExpressionNode.computed = true;
                memberExpressionNode.property = {
                    type: NodeType_1.NodeType.Literal,
                    value: memberExpressionNode.property.name,
                    raw: "'" + memberExpressionNode.property.name + "'"
                };
            }
            return memberExpressionNode;
        }
    }]);

    return MemberExpressionTransformer;
}(AbstractNodeTransformer_1.AbstractNodeTransformer);
MemberExpressionTransformer = tslib_1.__decorate([inversify_1.injectable(), tslib_1.__param(0, inversify_1.inject(ServiceIdentifiers_1.ServiceIdentifiers.IRandomGenerator)), tslib_1.__param(1, inversify_1.inject(ServiceIdentifiers_1.ServiceIdentifiers.IOptions)), tslib_1.__metadata("design:paramtypes", [Object, Object])], MemberExpressionTransformer);
exports.MemberExpressionTransformer = MemberExpressionTransformer;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiTWVtYmVyRXhwcmVzc2lvblRyYW5zZm9ybWVyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vc3JjL25vZGUtdHJhbnNmb3JtZXJzL2NvbnZlcnRpbmctdHJhbnNmb3JtZXJzL01lbWJlckV4cHJlc3Npb25UcmFuc2Zvcm1lci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFBQSwwQkFBK0M7QUFDL0MsbUNBQXdFO0FBUXhFLHlCQUFnRDtBQUVoRCx3Q0FBcUU7QUFDckUscUJBQXVDO0FBR3ZDO0FBQUEsQUFBYSxBQUEyQixBQUFDOztBQUtyQyx5Q0FDaUQsQUFBaUMsaUJBQ3pDLEFBQWlCO0FBRXRELEFBQUs7O3lKQUFDLEFBQWUsaUJBQUUsQUFBTyxBQUFDLEFBQUMsQUFDcEM7QUFBQyxBQUtNLEFBQVU7Ozs7Ozs7QUFDYixBQUFNO0FBQ0YsQUFBSyx1QkFBRSxlQUFDLEFBQWlCLE1BQUUsQUFBdUI7QUFDOUMsQUFBRSxBQUFDLHdCQUFDLE9BQUksS0FBQyxBQUFzQix1QkFBQyxBQUFJLEFBQUMsQUFBQyxPQUFDLEFBQUM7QUFDcEMsQUFBTSwrQkFBQyxBQUFJLE9BQUMsQUFBYSxjQUFDLEFBQUksTUFBRSxBQUFVLEFBQUMsQUFBQyxBQUNoRDtBQUFDLEFBQ0w7QUFBQyxBQUNKLEFBQUMsQUFDTjtBQVBXO0FBT1YsQUFrQk0sQUFBYTs7O3NDQUFFLEFBQTZDLHNCQUFFLEFBQXVCO0FBQ3hGLEFBQUUsQUFBQyxnQkFBQyxPQUFJLEtBQUMsQUFBZ0IsaUJBQUMsQUFBb0IscUJBQUMsQUFBUSxBQUFDLEFBQUMsV0FBQyxBQUFDO0FBQ3ZELEFBQUUsQUFBQyxvQkFBQyxBQUFvQixxQkFBQyxBQUFRLEFBQUMsVUFBQyxBQUFDO0FBQ2hDLEFBQU0sMkJBQUMsQUFBb0IsQUFBQyxBQUNoQztBQUFDO0FBRUQsQUFBb0IscUNBQUMsQUFBUSxXQUFHLEFBQUksQUFBQztBQUNyQyxBQUFvQixxQ0FBQyxBQUFRO0FBQ3pCLEFBQUksMEJBQUUsV0FBUSxTQUFDLEFBQU87QUFDdEIsQUFBSywyQkFBRSxBQUFvQixxQkFBQyxBQUFRLFNBQUMsQUFBSTtBQUN6QyxBQUFHLEFBQUUsK0JBQUksQUFBb0IscUJBQUMsQUFBUSxTQUFDLEFBQUksQUFBRyxBQUNqRCxBQUFDLEFBQ047QUFMb0M7QUFLbkM7QUFFRCxBQUFNLG1CQUFDLEFBQW9CLEFBQUMsQUFDaEM7QUFBQyxBQUNKOzs7O0VBekRnRCwwQkFBdUI7QUFBM0QsQUFBMkIsa0RBRHZDLFlBQVUsQUFBRSxjQU9KLG1CQUFBLFlBQU0sT0FBQyxxQkFBa0IsbUJBQUMsQUFBZ0IsQUFBQyxvQkFDM0MsbUJBQUEsWUFBTSxPQUFDLHFCQUFrQixtQkFBQyxBQUFRLEFBQUMsd0VBUC9CLEFBQTJCLEFBeUR2QztBQXpEWSxzQ0FBMkIiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBpbmplY3RhYmxlLCBpbmplY3QgfSBmcm9tICdpbnZlcnNpZnknO1xuaW1wb3J0IHsgU2VydmljZUlkZW50aWZpZXJzIH0gZnJvbSAnLi4vLi4vY29udGFpbmVyL1NlcnZpY2VJZGVudGlmaWVycyc7XG5cbmltcG9ydCAqIGFzIEVTVHJlZSBmcm9tICdlc3RyZWUnO1xuXG5pbXBvcnQgeyBJT3B0aW9ucyB9IGZyb20gJy4uLy4uL2ludGVyZmFjZXMvb3B0aW9ucy9JT3B0aW9ucyc7XG5pbXBvcnQgeyBJUmFuZG9tR2VuZXJhdG9yIH0gZnJvbSAnLi4vLi4vaW50ZXJmYWNlcy91dGlscy9JUmFuZG9tR2VuZXJhdG9yJztcbmltcG9ydCB7IElWaXNpdG9yIH0gZnJvbSAnLi4vLi4vaW50ZXJmYWNlcy9JVmlzaXRvcic7XG5cbmltcG9ydCB7IE5vZGVUeXBlIH0gZnJvbSAnLi4vLi4vZW51bXMvTm9kZVR5cGUnO1xuXG5pbXBvcnQgeyBBYnN0cmFjdE5vZGVUcmFuc2Zvcm1lciB9IGZyb20gJy4uL0Fic3RyYWN0Tm9kZVRyYW5zZm9ybWVyJztcbmltcG9ydCB7IE5vZGUgfSBmcm9tICcuLi8uLi9ub2RlL05vZGUnO1xuXG5AaW5qZWN0YWJsZSgpXG5leHBvcnQgY2xhc3MgTWVtYmVyRXhwcmVzc2lvblRyYW5zZm9ybWVyIGV4dGVuZHMgQWJzdHJhY3ROb2RlVHJhbnNmb3JtZXIge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7SVJhbmRvbUdlbmVyYXRvcn0gcmFuZG9tR2VuZXJhdG9yXG4gICAgICogQHBhcmFtIHtJT3B0aW9uc30gb3B0aW9uc1xuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yIChcbiAgICAgICAgQGluamVjdChTZXJ2aWNlSWRlbnRpZmllcnMuSVJhbmRvbUdlbmVyYXRvcikgcmFuZG9tR2VuZXJhdG9yOiBJUmFuZG9tR2VuZXJhdG9yLFxuICAgICAgICBAaW5qZWN0KFNlcnZpY2VJZGVudGlmaWVycy5JT3B0aW9ucykgb3B0aW9uczogSU9wdGlvbnNcbiAgICApIHtcbiAgICAgICAgc3VwZXIocmFuZG9tR2VuZXJhdG9yLCBvcHRpb25zKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHtJVmlzaXRvcn1cbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0VmlzaXRvciAoKTogSVZpc2l0b3Ige1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZW50ZXI6IChub2RlOiBFU1RyZWUuTm9kZSwgcGFyZW50Tm9kZTogRVNUcmVlLk5vZGUpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoTm9kZS5pc01lbWJlckV4cHJlc3Npb25Ob2RlKG5vZGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybU5vZGUobm9kZSwgcGFyZW50Tm9kZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHJlcGxhY2VzOlxuICAgICAqICAgICBvYmplY3QuaWRlbnRpZmllciA9IDE7XG4gICAgICpcbiAgICAgKiBvbjpcbiAgICAgKiAgICAgb2JqZWN0WydpZGVudGlmaWVyJ10gPSAxO1xuICAgICAqXG4gICAgICogYW5kIHNraXA6XG4gICAgICogICAgIG9iamVjdFtpZGVudGlmaWVyXSA9IDE7XG4gICAgICpcbiAgICAgKiBMaXRlcmFsIG5vZGUgd2lsbCBiZSBvYmZ1c2NhdGVkIGJ5IExpdGVyYWxUcmFuc2Zvcm1lclxuICAgICAqXG4gICAgICogQHBhcmFtIHtNZW1iZXJFeHByZXNzaW9ufSBtZW1iZXJFeHByZXNzaW9uTm9kZVxuICAgICAqIEBwYXJhbSB7Tm9kZX0gcGFyZW50Tm9kZVxuICAgICAqIEByZXR1cm5zIHtOb2RlfVxuICAgICAqL1xuICAgIHB1YmxpYyB0cmFuc2Zvcm1Ob2RlIChtZW1iZXJFeHByZXNzaW9uTm9kZTogRVNUcmVlLk1lbWJlckV4cHJlc3Npb24sIHBhcmVudE5vZGU6IEVTVHJlZS5Ob2RlKTogRVNUcmVlLk5vZGUge1xuICAgICAgICBpZiAoTm9kZS5pc0lkZW50aWZpZXJOb2RlKG1lbWJlckV4cHJlc3Npb25Ob2RlLnByb3BlcnR5KSkge1xuICAgICAgICAgICAgaWYgKG1lbWJlckV4cHJlc3Npb25Ob2RlLmNvbXB1dGVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1lbWJlckV4cHJlc3Npb25Ob2RlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBtZW1iZXJFeHByZXNzaW9uTm9kZS5jb21wdXRlZCA9IHRydWU7XG4gICAgICAgICAgICBtZW1iZXJFeHByZXNzaW9uTm9kZS5wcm9wZXJ0eSA9IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBOb2RlVHlwZS5MaXRlcmFsLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBtZW1iZXJFeHByZXNzaW9uTm9kZS5wcm9wZXJ0eS5uYW1lLFxuICAgICAgICAgICAgICAgIHJhdzogYCcke21lbWJlckV4cHJlc3Npb25Ob2RlLnByb3BlcnR5Lm5hbWV9J2BcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbWVtYmVyRXhwcmVzc2lvbk5vZGU7XG4gICAgfVxufVxuIl19