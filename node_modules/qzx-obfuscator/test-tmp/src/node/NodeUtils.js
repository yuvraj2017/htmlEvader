"use strict";

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

Object.defineProperty(exports, "__esModule", { value: true });
var escodegen = require("escodegen-wallaby");
var esprima = require("esprima");
var estraverse = require("estraverse");
var NodeType_1 = require("../enums/NodeType");
var Node_1 = require("./Node");
var Nodes_1 = require("./Nodes");

var NodeUtils = function () {
    function NodeUtils() {
        _classCallCheck(this, NodeUtils);
    }

    _createClass(NodeUtils, null, [{
        key: "addXVerbatimPropertyToLiterals",
        value: function addXVerbatimPropertyToLiterals(astTree) {
            NodeUtils.typedReplace(astTree, NodeType_1.NodeType.Literal, {
                leave: function leave(literalNode) {
                    literalNode['x-verbatim-property'] = {
                        content: literalNode.raw,
                        precedence: escodegen.Precedence.Primary
                    };
                }
            });
            return astTree;
        }
    }, {
        key: "clone",
        value: function clone(astTree) {
            var cloneRecursive = function cloneRecursive(node) {
                var copy = {};
                Object.keys(node).filter(function (property) {
                    return property !== 'parentNode';
                }).forEach(function (property) {
                    var value = node[property];
                    var clonedValue = void 0;
                    if (value === null || value instanceof RegExp) {
                        clonedValue = value;
                    } else if (Array.isArray(value)) {
                        clonedValue = value.map(cloneRecursive);
                    } else if ((typeof value === "undefined" ? "undefined" : _typeof(value)) === 'object') {
                        clonedValue = cloneRecursive(value);
                    } else {
                        clonedValue = value;
                    }
                    copy[property] = clonedValue;
                });
                return copy;
            };
            return NodeUtils.parentize(cloneRecursive(astTree));
        }
    }, {
        key: "convertCodeToStructure",
        value: function convertCodeToStructure(code) {
            var structure = esprima.parse(code);
            structure = NodeUtils.addXVerbatimPropertyToLiterals(structure);
            structure = NodeUtils.parentize(structure);
            return structure.body;
        }
    }, {
        key: "convertStructureToCode",
        value: function convertStructureToCode(structure) {
            var code = '';
            structure.forEach(function (node) {
                code += escodegen.generate(node, {
                    sourceMapWithCode: true
                }).code;
            });
            return code;
        }
    }, {
        key: "getBlockStatementNodeByIndex",
        value: function getBlockStatementNodeByIndex(node) {
            var index = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

            if (Node_1.Node.isNodeHasBlockStatement(node)) {
                if (node.body[index] === undefined) {
                    throw new ReferenceError("Wrong index `" + index + "`. Block-statement body length is `" + node.body.length + "`");
                }
                return node.body[index];
            }
            throw new TypeError('The specified node have no a block-statement');
        }
    }, {
        key: "getBlockScopesOfNode",
        value: function getBlockScopesOfNode(node) {
            var blockScopes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];

            var parentNode = node.parentNode;
            if (!parentNode) {
                throw new ReferenceError('`parentNode` property of given node is `undefined`');
            }
            if (Node_1.Node.isBlockStatementNode(parentNode)) {
                if (!parentNode.parentNode) {
                    throw new ReferenceError('`parentNode` property of `parentNode` of given node is `undefined`');
                }
                if (NodeUtils.nodesWithBlockScope.indexOf(parentNode.parentNode.type) !== -1) {
                    blockScopes.push(parentNode);
                }
            }
            if (!Node_1.Node.isProgramNode(parentNode)) {
                return NodeUtils.getBlockScopesOfNode(parentNode, blockScopes);
            }
            blockScopes.push(parentNode);
            return blockScopes;
        }
    }, {
        key: "getNodeBlockScopeDepth",
        value: function getNodeBlockScopeDepth(node) {
            var depth = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

            var parentNode = node.parentNode;
            if (!parentNode) {
                throw new ReferenceError('`parentNode` property of given node is `undefined`');
            }
            if (Node_1.Node.isProgramNode(parentNode)) {
                return depth;
            }
            if (Node_1.Node.isBlockStatementNode(node) && NodeUtils.nodesWithBlockScope.indexOf(parentNode.type) !== -1) {
                return NodeUtils.getNodeBlockScopeDepth(parentNode, ++depth);
            }
            return NodeUtils.getNodeBlockScopeDepth(parentNode, depth);
        }
    }, {
        key: "getUnaryExpressionArgumentNode",
        value: function getUnaryExpressionArgumentNode(unaryExpressionNode) {
            if (Node_1.Node.isUnaryExpressionNode(unaryExpressionNode.argument)) {
                return NodeUtils.getUnaryExpressionArgumentNode(unaryExpressionNode.argument);
            }
            return unaryExpressionNode.argument;
        }
    }, {
        key: "parentize",
        value: function parentize(astTree) {
            var isRootNode = true;
            estraverse.traverse(astTree, {
                enter: function enter(node, parentNode) {
                    var value = void 0;
                    if (isRootNode) {
                        if (node.type === NodeType_1.NodeType.Program) {
                            value = node;
                        } else {
                            value = Nodes_1.Nodes.getProgramNode([node]);
                            value.parentNode = value;
                        }
                        isRootNode = false;
                    } else {
                        value = parentNode || node;
                    }
                    node.parentNode = value;
                    node.obfuscatedNode = false;
                }
            });
            return astTree;
        }
    }, {
        key: "typedReplace",
        value: function typedReplace(astTree, nodeType, visitor) {
            NodeUtils.typedTraverse(astTree, nodeType, visitor, 'replace');
        }
    }, {
        key: "typedTraverse",
        value: function typedTraverse(astTree, nodeType, visitor) {
            var traverseType = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'traverse';

            estraverse[traverseType](astTree, {
                enter: function enter(node, parentNode) {
                    if (node.type === nodeType && visitor.enter) {
                        return visitor.enter(node, parentNode);
                    }
                },
                leave: function leave(node, parentNode) {
                    if (node.type === nodeType && visitor.leave) {
                        return visitor.leave(node, parentNode);
                    }
                }
            });
        }
    }]);

    return NodeUtils;
}();

NodeUtils.nodesWithBlockScope = [NodeType_1.NodeType.ArrowFunctionExpression, NodeType_1.NodeType.FunctionDeclaration, NodeType_1.NodeType.FunctionExpression, NodeType_1.NodeType.MethodDefinition, NodeType_1.NodeType.Program];
exports.NodeUtils = NodeUtils;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiTm9kZVV0aWxzLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vc3JjL25vZGUvTm9kZVV0aWxzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFBLHdCQUErQztBQUMvQyxzQkFBbUM7QUFDbkMseUJBQXlDO0FBTXpDLHlCQUE2QztBQUU3QyxxQkFBOEI7QUFDOUIsc0JBQWdDLEFBRWhDOztJQWdCVyxBQUFNLEFBQUMsQUFBOEI7Ozs7Ozs7dURBQTBCLEFBQVU7QUFDNUUsQUFBUyxzQkFBQyxBQUFZLGFBQUMsQUFBTyxTQUFFLFdBQVEsU0FBQyxBQUFPO0FBQzVDLEFBQUssdUJBQUUsZUFBQyxBQUEyQjtBQUMvQixBQUFXLGdDQUFDLEFBQXFCLEFBQUM7QUFDOUIsQUFBTyxpQ0FBRyxBQUFXLFlBQUMsQUFBRztBQUN6QixBQUFVLG9DQUFFLEFBQVMsVUFBQyxBQUFVLFdBQUMsQUFBTyxBQUMzQyxBQUFDLEFBQ047QUFKeUM7QUFJeEMsQUFDSixBQUFDLEFBQUM7QUFQK0M7QUFTbEQsQUFBTSxtQkFBQyxBQUFPLEFBQUMsQUFDbkI7QUFBQyxBQU1NLEFBQU0sQUFBQyxBQUFLOzs7OEJBQTBCLEFBQVU7QUFDbkQsZ0JBQU0sQUFBYyxpQkFBbUIsd0JBQUMsQUFBTztBQUMzQyxvQkFBTSxBQUFJLE9BQXlCLEFBQUUsQUFBQztBQUV0QyxBQUFNLHVCQUNELEFBQUksS0FBQyxBQUFJLEFBQUMsTUFDVixBQUFNLGlCQUFFLEFBQWdCO0FBQWpCLDJCQUFzQixBQUFRLGFBQUssQUFBWSxBQUFDO21CQUN2RCxBQUFPLFFBQUMsVUFBQyxBQUFnQjtBQUN0Qix3QkFBTSxBQUFLLFFBQStCLEFBQUssS0FBQyxBQUFRLEFBQUMsQUFBQztBQUUxRCx3QkFBSSxBQUF1QixBQUFDO0FBRTVCLEFBQUUsQUFBQyx3QkFBQyxBQUFLLFVBQUssQUFBSSxRQUFJLEFBQUssaUJBQVksQUFBTSxBQUFDLFFBQUMsQUFBQztBQUM1QyxBQUFXLHND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LEFBQWtCLG9CQUMzQixXQUFRLFNBQUMsQUFBZ0Isa0JBQ3pCLFdBQVEsU0FBQyxBQUFPLEFBQ25CLEFBQUM7QUFWTixvQkFzUEMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBlc2NvZGVnZW4gZnJvbSAnZXNjb2RlZ2VuLXdhbGxhYnknO1xuaW1wb3J0ICogYXMgZXNwcmltYSBmcm9tICdlc3ByaW1hJztcbmltcG9ydCAqIGFzIGVzdHJhdmVyc2UgZnJvbSAnZXN0cmF2ZXJzZSc7XG5pbXBvcnQgKiBhcyBFU1RyZWUgZnJvbSAnZXN0cmVlJztcblxuaW1wb3J0IHsgVE5vZGVXaXRoQmxvY2tTdGF0ZW1lbnQgfSBmcm9tICcuLi90eXBlcy9ub2RlL1ROb2RlV2l0aEJsb2NrU3RhdGVtZW50JztcbmltcG9ydCB7IFRTdGF0ZW1lbnQgfSBmcm9tICcuLi90eXBlcy9ub2RlL1RTdGF0ZW1lbnQnO1xuXG5pbXBvcnQgeyBOb2RlVHlwZSB9IGZyb20gJy4uL2VudW1zL05vZGVUeXBlJztcblxuaW1wb3J0IHsgTm9kZSB9IGZyb20gJy4vTm9kZSc7XG5pbXBvcnQgeyBOb2RlcyB9IGZyb20gJy4vTm9kZXMnO1xuXG5leHBvcnQgY2xhc3MgTm9kZVV0aWxzIHtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7c3RyaW5nW119XG4gICAgICovXG4gICAgcHJpdmF0ZSBzdGF0aWMgcmVhZG9ubHkgbm9kZXNXaXRoQmxvY2tTY29wZTogc3RyaW5nW10gPSBbXG4gICAgICAgIE5vZGVUeXBlLkFycm93RnVuY3Rpb25FeHByZXNzaW9uLFxuICAgICAgICBOb2RlVHlwZS5GdW5jdGlvbkRlY2xhcmF0aW9uLFxuICAgICAgICBOb2RlVHlwZS5GdW5jdGlvbkV4cHJlc3Npb24sXG4gICAgICAgIE5vZGVUeXBlLk1ldGhvZERlZmluaXRpb24sXG4gICAgICAgIE5vZGVUeXBlLlByb2dyYW1cbiAgICBdO1xuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtUfSBhc3RUcmVlXG4gICAgICogQHJldHVybnMge1R9XG4gICAgICovXG4gICAgcHVibGljIHN0YXRpYyBhZGRYVmVyYmF0aW1Qcm9wZXJ0eVRvTGl0ZXJhbHMgPFQgZXh0ZW5kcyBFU1RyZWUuTm9kZT4gKGFzdFRyZWU6IFQpOiBUIHtcbiAgICAgICAgTm9kZVV0aWxzLnR5cGVkUmVwbGFjZShhc3RUcmVlLCBOb2RlVHlwZS5MaXRlcmFsLCB7XG4gICAgICAgICAgICBsZWF2ZTogKGxpdGVyYWxOb2RlOiBFU1RyZWUuTGl0ZXJhbCkgPT4ge1xuICAgICAgICAgICAgICAgIGxpdGVyYWxOb2RlWyd4LXZlcmJhdGltLXByb3BlcnR5J10gPSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnQgOiBsaXRlcmFsTm9kZS5yYXcsXG4gICAgICAgICAgICAgICAgICAgIHByZWNlZGVuY2U6IGVzY29kZWdlbi5QcmVjZWRlbmNlLlByaW1hcnlcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gYXN0VHJlZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1R9IGFzdFRyZWVcbiAgICAgKiBAcmV0dXJucyB7VH1cbiAgICAgKi9cbiAgICBwdWJsaWMgc3RhdGljIGNsb25lIDxUIGV4dGVuZHMgRVNUcmVlLk5vZGU+IChhc3RUcmVlOiBUKTogVCB7XG4gICAgICAgIGNvbnN0IGNsb25lUmVjdXJzaXZlOiAobm9kZTogVCkgPT4gVCA9IChub2RlOiBUKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBjb3B5OiB7W2tleTogc3RyaW5nXTogYW55fSA9IHt9O1xuXG4gICAgICAgICAgICBPYmplY3RcbiAgICAgICAgICAgICAgICAua2V5cyhub2RlKVxuICAgICAgICAgICAgICAgIC5maWx0ZXIoKHByb3BlcnR5OiBzdHJpbmcpID0+IHByb3BlcnR5ICE9PSAncGFyZW50Tm9kZScpXG4gICAgICAgICAgICAgICAgLmZvckVhY2goKHByb3BlcnR5OiBzdHJpbmcpOiB2b2lkID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdmFsdWU6IGFueSA9ICg8e1trZXk6IHN0cmluZ106IGFueX0+bm9kZSlbcHJvcGVydHldO1xuXG4gICAgICAgICAgICAgICAgICAgIGxldCBjbG9uZWRWYWx1ZTogYW55IHwgbnVsbDtcblxuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT09IG51bGwgfHwgdmFsdWUgaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsb25lZFZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsb25lZFZhbHVlID0gdmFsdWUubWFwKGNsb25lUmVjdXJzaXZlKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjbG9uZWRWYWx1ZSA9IGNsb25lUmVjdXJzaXZlKHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsb25lZFZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBjb3B5W3Byb3BlcnR5XSA9IGNsb25lZFZhbHVlO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICByZXR1cm4gPFQ+Y29weTtcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gTm9kZVV0aWxzLnBhcmVudGl6ZShjbG9uZVJlY3Vyc2l2ZShhc3RUcmVlKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNvZGVcbiAgICAgKiBAcmV0dXJucyB7VFN0YXRlbWVudFtdfVxuICAgICAqL1xuICAgIHB1YmxpYyBzdGF0aWMgY29udmVydENvZGVUb1N0cnVjdHVyZSAoY29kZTogc3RyaW5nKTogVFN0YXRlbWVudFtdIHtcbiAgICAgICAgbGV0IHN0cnVjdHVyZTogRVNUcmVlLlByb2dyYW0gPSBlc3ByaW1hLnBhcnNlKGNvZGUpO1xuXG4gICAgICAgIHN0cnVjdHVyZSA9IE5vZGVVdGlscy5hZGRYVmVyYmF0aW1Qcm9wZXJ0eVRvTGl0ZXJhbHMoc3RydWN0dXJlKTtcbiAgICAgICAgc3RydWN0dXJlID0gTm9kZVV0aWxzLnBhcmVudGl6ZShzdHJ1Y3R1cmUpO1xuXG4gICAgICAgIHJldHVybiA8VFN0YXRlbWVudFtdPnN0cnVjdHVyZS5ib2R5O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7Tm9kZVtdfSBzdHJ1Y3R1cmVcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqL1xuICAgIHB1YmxpYyBzdGF0aWMgY29udmVydFN0cnVjdHVyZVRvQ29kZSAoc3RydWN0dXJlOiBFU1RyZWUuTm9kZVtdKTogc3RyaW5nIHtcbiAgICAgICAgbGV0IGNvZGU6IHN0cmluZyA9ICcnO1xuXG4gICAgICAgIHN0cnVjdHVyZS5mb3JFYWNoKChub2RlOiBFU1RyZWUuTm9kZSkgPT4ge1xuICAgICAgICAgICAgY29kZSArPSBlc2NvZGVnZW4uZ2VuZXJhdGUobm9kZSwge1xuICAgICAgICAgICAgICAgIHNvdXJjZU1hcFdpdGhDb2RlOiB0cnVlXG4gICAgICAgICAgICB9KS5jb2RlO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gY29kZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge05vZGV9IG5vZGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXhcbiAgICAgKiBAcmV0dXJucyB7Tm9kZX1cbiAgICAgKi9cbiAgICBwdWJsaWMgc3RhdGljIGdldEJsb2NrU3RhdGVtZW50Tm9kZUJ5SW5kZXggKG5vZGU6IEVTVHJlZS5Ob2RlLCBpbmRleDogbnVtYmVyID0gMCk6IEVTVHJlZS5Ob2RlIHtcbiAgICAgICAgaWYgKE5vZGUuaXNOb2RlSGFzQmxvY2tTdGF0ZW1lbnQobm9kZSkpIHtcbiAgICAgICAgICAgIGlmIChub2RlLmJvZHlbaW5kZXhdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoYFdyb25nIGluZGV4IFxcYCR7aW5kZXh9XFxgLiBCbG9jay1zdGF0ZW1lbnQgYm9keSBsZW5ndGggaXMgXFxgJHtub2RlLmJvZHkubGVuZ3RofVxcYGApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gbm9kZS5ib2R5W2luZGV4XTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBzcGVjaWZpZWQgbm9kZSBoYXZlIG5vIGEgYmxvY2stc3RhdGVtZW50Jyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtOb2RlfSBub2RlXG4gICAgICogQHBhcmFtIHtUTm9kZVdpdGhCbG9ja1N0YXRlbWVudFtdfSBibG9ja1Njb3Blc1xuICAgICAqIEByZXR1cm5zIHtUTm9kZVdpdGhCbG9ja1N0YXRlbWVudFtdfVxuICAgICAqL1xuICAgIHB1YmxpYyBzdGF0aWMgZ2V0QmxvY2tTY29wZXNPZk5vZGUgKG5vZGU6IEVTVHJlZS5Ob2RlLCBibG9ja1Njb3BlczogVE5vZGVXaXRoQmxvY2tTdGF0ZW1lbnRbXSA9IFtdKTogVE5vZGVXaXRoQmxvY2tTdGF0ZW1lbnRbXSB7XG4gICAgICAgIGNvbnN0IHBhcmVudE5vZGU6IEVTVHJlZS5Ob2RlIHwgdW5kZWZpbmVkID0gbm9kZS5wYXJlbnROb2RlO1xuXG4gICAgICAgIGlmICghcGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKCdgcGFyZW50Tm9kZWAgcHJvcGVydHkgb2YgZ2l2ZW4gbm9kZSBpcyBgdW5kZWZpbmVkYCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKE5vZGUuaXNCbG9ja1N0YXRlbWVudE5vZGUocGFyZW50Tm9kZSkpIHtcbiAgICAgICAgICAgIGlmICghcGFyZW50Tm9kZS5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKCdgcGFyZW50Tm9kZWAgcHJvcGVydHkgb2YgYHBhcmVudE5vZGVgIG9mIGdpdmVuIG5vZGUgaXMgYHVuZGVmaW5lZGAnKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKE5vZGVVdGlscy5ub2Rlc1dpdGhCbG9ja1Njb3BlLmluY2x1ZGVzKHBhcmVudE5vZGUucGFyZW50Tm9kZS50eXBlKSkge1xuICAgICAgICAgICAgICAgIGJsb2NrU2NvcGVzLnB1c2gocGFyZW50Tm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIU5vZGUuaXNQcm9ncmFtTm9kZShwYXJlbnROb2RlKSkge1xuICAgICAgICAgICAgcmV0dXJuIE5vZGVVdGlscy5nZXRCbG9ja1Njb3Blc09mTm9kZShwYXJlbnROb2RlLCBibG9ja1Njb3Blcyk7XG4gICAgICAgIH1cblxuICAgICAgICBibG9ja1Njb3Blcy5wdXNoKHBhcmVudE5vZGUpO1xuXG4gICAgICAgIHJldHVybiBibG9ja1Njb3BlcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge05vZGV9IG5vZGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZGVwdGhcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqL1xuICAgIHB1YmxpYyBzdGF0aWMgZ2V0Tm9kZUJsb2NrU2NvcGVEZXB0aCAobm9kZTogRVNUcmVlLk5vZGUsIGRlcHRoOiBudW1iZXIgPSAwKTogbnVtYmVyIHtcbiAgICAgICAgY29uc3QgcGFyZW50Tm9kZTogRVNUcmVlLk5vZGUgfCB1bmRlZmluZWQgPSBub2RlLnBhcmVudE5vZGU7XG5cbiAgICAgICAgaWYgKCFwYXJlbnROb2RlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoJ2BwYXJlbnROb2RlYCBwcm9wZXJ0eSBvZiBnaXZlbiBub2RlIGlzIGB1bmRlZmluZWRgJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoTm9kZS5pc1Byb2dyYW1Ob2RlKHBhcmVudE5vZGUpKSB7XG4gICAgICAgICAgICByZXR1cm4gZGVwdGg7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoTm9kZS5pc0Jsb2NrU3RhdGVtZW50Tm9kZShub2RlKSAmJiBOb2RlVXRpbHMubm9kZXNXaXRoQmxvY2tTY29wZS5pbmNsdWRlcyhwYXJlbnROb2RlLnR5cGUpKSB7XG4gICAgICAgICAgICByZXR1cm4gTm9kZVV0aWxzLmdldE5vZGVCbG9ja1Njb3BlRGVwdGgocGFyZW50Tm9kZSwgKytkZXB0aCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gTm9kZVV0aWxzLmdldE5vZGVCbG9ja1Njb3BlRGVwdGgocGFyZW50Tm9kZSwgZGVwdGgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7VW5hcnlFeHByZXNzaW9ufSB1bmFyeUV4cHJlc3Npb25Ob2RlXG4gICAgICogQHJldHVybnMge05vZGV9XG4gICAgICovXG4gICAgcHVibGljIHN0YXRpYyBnZXRVbmFyeUV4cHJlc3Npb25Bcmd1bWVudE5vZGUgKHVuYXJ5RXhwcmVzc2lvbk5vZGU6IEVTVHJlZS5VbmFyeUV4cHJlc3Npb24pOiBFU1RyZWUuTm9kZSB7XG4gICAgICAgIGlmIChOb2RlLmlzVW5hcnlFeHByZXNzaW9uTm9kZSh1bmFyeUV4cHJlc3Npb25Ob2RlLmFyZ3VtZW50KSkge1xuICAgICAgICAgICAgcmV0dXJuIE5vZGVVdGlscy5nZXRVbmFyeUV4cHJlc3Npb25Bcmd1bWVudE5vZGUodW5hcnlFeHByZXNzaW9uTm9kZS5hcmd1bWVudCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdW5hcnlFeHByZXNzaW9uTm9kZS5hcmd1bWVudDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1R9IGFzdFRyZWVcbiAgICAgKiBAcmV0dXJucyB7VH1cbiAgICAgKi9cbiAgICBwdWJsaWMgc3RhdGljIHBhcmVudGl6ZSA8VCBleHRlbmRzIEVTVHJlZS5Ob2RlPiAoYXN0VHJlZTogVCk6IFQge1xuICAgICAgICBsZXQgaXNSb290Tm9kZTogYm9vbGVhbiA9IHRydWU7XG5cbiAgICAgICAgZXN0cmF2ZXJzZS50cmF2ZXJzZShhc3RUcmVlLCB7XG4gICAgICAgICAgICBlbnRlcjogKG5vZGU6IEVTVHJlZS5Ob2RlLCBwYXJlbnROb2RlOiBFU1RyZWUuTm9kZSk6IGFueSA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IHZhbHVlOiBFU1RyZWUuTm9kZTtcblxuICAgICAgICAgICAgICAgIGlmIChpc1Jvb3ROb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChub2RlLnR5cGUgPT09IE5vZGVUeXBlLlByb2dyYW0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gbm9kZTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gTm9kZXMuZ2V0UHJvZ3JhbU5vZGUoPFRTdGF0ZW1lbnRbXT5bbm9kZV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUucGFyZW50Tm9kZSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaXNSb290Tm9kZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gcGFyZW50Tm9kZSB8fCBub2RlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIG5vZGUucGFyZW50Tm9kZSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIG5vZGUub2JmdXNjYXRlZE5vZGUgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIGFzdFRyZWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtOb2RlfSBhc3RUcmVlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5vZGVUeXBlXG4gICAgICogQHBhcmFtIHt2aXNpdG9yfSB2aXNpdG9yXG4gICAgICovXG4gICAgcHVibGljIHN0YXRpYyB0eXBlZFJlcGxhY2UgKFxuICAgICAgICBhc3RUcmVlOiBFU1RyZWUuTm9kZSxcbiAgICAgICAgbm9kZVR5cGU6IHN0cmluZyxcbiAgICAgICAgdmlzaXRvcjoge2VudGVyPzogKG5vZGU6IEVTVHJlZS5Ob2RlKSA9PiB2b2lkLCBsZWF2ZT86IChub2RlOiBFU1RyZWUuTm9kZSkgPT4gdm9pZH0sXG4gICAgKTogdm9pZCB7XG4gICAgICAgIE5vZGVVdGlscy50eXBlZFRyYXZlcnNlKGFzdFRyZWUsIG5vZGVUeXBlLCB2aXNpdG9yLCAncmVwbGFjZScpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7Tm9kZX0gYXN0VHJlZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBub2RlVHlwZVxuICAgICAqIEBwYXJhbSB7VmlzaXRvcn0gdmlzaXRvclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0cmF2ZXJzZVR5cGVcbiAgICAgKi9cbiAgICBwdWJsaWMgc3RhdGljIHR5cGVkVHJhdmVyc2UgKFxuICAgICAgICBhc3RUcmVlOiBFU1RyZWUuTm9kZSxcbiAgICAgICAgbm9kZVR5cGU6IHN0cmluZyxcbiAgICAgICAgdmlzaXRvcjogZXN0cmF2ZXJzZS5WaXNpdG9yLFxuICAgICAgICB0cmF2ZXJzZVR5cGU6IHN0cmluZyA9ICd0cmF2ZXJzZSdcbiAgICApOiB2b2lkIHtcbiAgICAgICAgKDxhbnk+ZXN0cmF2ZXJzZSlbdHJhdmVyc2VUeXBlXShhc3RUcmVlLCB7XG4gICAgICAgICAgICBlbnRlcjogKG5vZGU6IEVTVHJlZS5Ob2RlLCBwYXJlbnROb2RlOiBFU1RyZWUuTm9kZSk6IGFueSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUudHlwZSA9PT0gbm9kZVR5cGUgJiYgdmlzaXRvci5lbnRlcikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmlzaXRvci5lbnRlcihub2RlLCBwYXJlbnROb2RlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbGVhdmU6IChub2RlOiBFU1RyZWUuTm9kZSwgcGFyZW50Tm9kZTogRVNUcmVlLk5vZGUpOiBhbnkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChub2RlLnR5cGUgPT09IG5vZGVUeXBlICYmIHZpc2l0b3IubGVhdmUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZpc2l0b3IubGVhdmUobm9kZSwgcGFyZW50Tm9kZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG59XG4iXX0=